[{"content":"第三章 进程管理 3.1 概述 3.1.1 程序的顺序执行和并发执行 1. 程序的顺序执行 特点： 顺序性：按程序结构依次执行（可能包含分支或循环）。 封闭性：独占所有资源，程序执行不受外界影响。 可再现性：相同初始条件必定得到相同结果。 2. 程序的并发执行 定义：多个程序段在时间上重叠执行（一个未结束，另一个已开始）。 并发 vs 并行： 并发 并行 一段时间内交替执行 同一物理时刻同时执行 特征： 间断性：程序执行“走走停停”，时序可能被打断。 失去封闭性：共享资源导致状态受其他程序影响。 失去可再现性：执行结果因调度顺序不同而不同。 问题举例： 共享堆栈时，getaddr()和reladdr()并发执行可能导致错误结果。 并发执行条件： 需避免共享资源冲突（通过互斥、同步机制）。 3.1.2 进程的定义与特征 1. 进程定义 定义：程序在数据集上的一次动态执行活动，是资源分配的基本单位。 组成：程序 + 数据 + PCB（进程控制块）。 2. 进程特征 特征 说明 动态性 进程从创建到消亡经历状态变化（运行、就绪、阻塞）。 独立性 各进程拥有独立地址空间，除非通过进程间通信（IPC）交互。 并发性 多个进程可同时推进执行。 异步性 进程执行速度不可预测，需同步机制协调。 结构化 由代码段、数据段和 PCB 组成。 3.1.3 进程与程序的区别 对比项 进程 程序 本质 动态执行实体 静态指令集合 生命周期 短暂（创建→运行→终止） 永久存储 组成 程序 + 数据 + PCB 代码文件 资源竞争 是资源分配的基本单位 无资源竞争 并发性 支持并发/并行执行 无 3.1.4 进程与作业的关系 作业：用户提交的任务实体（如批处理作业）。 关系： 一个作业由多个进程组成（至少一个进程）。 作业概念主要用于批处理系统；进程用于所有多道系统。 示例：编译作业可能包含预处理、编译、链接等多个进程。 Q\u0026amp;A Q1: 并发执行可能导致结果不可再现的原因是什么？ A：共享资源冲突。例如，两个进程同时修改共享变量 x 时，若未同步，执行顺序不同会导致结果不同。\nQ2: 进程的基本特征包括哪些？ A：动态性、独立性、并发性、异步性、结构化。\nQ3: 进程和程序的本质区别是什么？ A：动态性 vs 静态性。进程是执行中的动态实体，程序是静态代码。\nQ4: 进程从运行态变为阻塞态的原因可能是什么？ A：等待 I/O 完成 或 请求系统服务未就绪。\nQ5: 进程控制块（PCB）的作用是什么？ A：记录进程状态、资源分配、调度信息，是操作系统感知和管理进程的唯一标识。\n3.2 进程的描述 3.2.1 进程的组成 进程 = 程序 + 数据 + PCB（进程控制块） 程序：进程执行的代码段。 数据：进程处理的对象（变量、堆栈等）。 PCB：记录进程状态、资源分配、调度信息等，是操作系统的管理依据。 3.2.2 进程控制块（PCB） 1. PCB的功能 唯一标识进程，操作系统通过PCB感知和管理进程。 记录动态特性（状态、优先级、资源占用等）。 存储CPU现场保护信息（寄存器值、程序计数器等）。 2. PCB的特征 常驻内存，随进程创建/撤销而出现/消失。 与进程一一对应，是进程存在的唯一标志。 3. PCB的内容 分类 具体内容 描述信息 进程ID、进程名、用户ID、进程组关系。 控制信息 当前状态、优先级、代码入口地址、同步机制（如信号量）。 资源信息 虚拟地址空间状态、打开文件列表、内存分配情况。 CPU现场 寄存器值（通用寄存器、程序计数器PC、状态寄存器PSW、栈指针）。 3.2.3 进程上下文 1. 定义 进程执行全过程的静态描述，包括用户地址空间、寄存器和核心数据结构。 2. 组成 类型 内容 用户级上下文 用户程序段（代码、数据、堆栈）。 寄存器级上下文 CPU寄存器值（PC、PSW、栈指针等）。 系统级上下文 静态部分（PCB）、动态部分（核心栈，用于系统调用时的上下文切换）。 3.2.4 PCB的组织方式 1. 链表方式 按状态分类：就绪链表、阻塞链表。 优点：动态管理灵活，适合频繁插入/删除。 示例：\n2. 索引表方式 每个状态对应一个索引表（如就绪索引表、阻塞索引表）。 优点：查询速度快，适合固定状态管理。 示例：\n3.2.5 进程的状态及其转换 1. 三种基本状态 状态 说明 就绪态 已具备运行条件，等待CPU分配。 运行态 占用CPU执行指令。 阻塞态 因等待事件（如I/O完成）无法继续执行。 2. 状态转换 此处少内容\n运行→就绪：时间片用完或高优先级进程抢占。 运行→阻塞：等待资源或事件（如I/O请求）。 阻塞→就绪：等待事件完成（如I/O结束）。 3. 扩展状态 创建态：进程正在被创建（分配PCB、初始化资源）。 终止态：进程已结束，释放资源但保留PCB信息。 挂起态：进程被移到外存，分为就绪挂起和阻塞挂起。 4. 挂起模型 此处少内容\n状态 内存/外存 是否可运行 就绪挂起 外存 是（需激活） 阻塞挂起 外存 否（需事件） Q\u0026amp;A Q1: PCB中存储哪些关键控制信息？\nA：包括当前状态、优先级、代码入口地址、同步机制（如信号量）、资源占用信息（如打开文件列表）。\nQ2: 进程从运行态转为阻塞态的可能原因是什么？\nA：等待I/O操作完成、请求系统服务未就绪（如申请内存失败）。\nQ3: 挂起状态的进程如何恢复执行？\nA：通过激活原语将进程从外存移回内存，状态转换为就绪态或阻塞态。\nQ4: 进程上下文切换时，哪些内容需要保存？\nA：寄存器值（PC、PSW、栈指针）、核心栈信息、资源占用状态。\nQ5: 为什么PCB需要常驻内存？\nA：操作系统需快速访问PCB以管理进程状态，若存于外存会导致频繁I/O，降低效率。\n3.3 进程控制 3.3.1 进程控制的功能 核心功能： 创建/撤销进程、挂起/激活进程、管理进程状态转换。 确保进程有序共享资源并正确执行。 1. 原语（Primitive） 定义：由多条指令构成的原子操作，执行不可中断（要么全部完成，要么全部不执行）。 类型： 类型 说明 机器指令级原语 硬件支持，禁止中断（如 test-and-set 指令）。 功能级原语 软件实现，允许中断但不可并发（如进程创建原语 fork()）。 3.3.2 进程控制的主要原语 1. 进程创建原语 主要任务： 分配 PCB、分配唯一 PID、初始化资源（内存、文件）、设置进程上下文、链接到就绪队列。 触发事件： 用户登录（分时系统） 作业调度（批处理系统） 提供服务（如打印进程） 应用请求（用户程序主动创建）。 子进程创建方式： 方式 说明 fork() 复制父进程上下文，生成新进程（UNIX 常用）。 spawn() 创建新进程并加载新程序（Windows 常用）。 exec() 加载新程序覆盖当前进程（不生成新进程）。 父子进程关系： 继承内容：环境变量、打开文件、共享存储区、信号处理表等。 不继承内容：进程 ID（PID）、父进程 PID、资源占用统计。 2. 进程撤销原语（Destroy） 触发原因： 进程正常结束、发生致命错误、被父进程终止、系统资源不足。 功能： 释放资源（内存、文件）、移除 PCB、更新进程树结构。 3. 进程阻塞原语（Block） 触发原因： 等待 I/O 完成、请求资源未就绪、等待同步信号（如信号量）。 处理过程： 保存 CPU 现场 → 更新 PCB 状态为阻塞 → 移入阻塞队列 → 触发调度。 4. 进程唤醒原语（Wakeup） 触发原因： 等待事件完成（如 I/O 结束）、其他进程释放资源。 处理方式： 更新 PCB 状态为就绪 → 移入就绪队列 → 触发调度。 5. 挂起原语（Suspend） 原因： 系统负载过高、调试需要、用户主动挂起。 操作： 将进程内存映像移至外存 → 更新状态为就绪挂起/阻塞挂起。 6. 激活原语（Activate） 功能： 将挂起进程移回内存 → 状态转换为就绪态/阻塞态。 3.3.3 Unix 的进程管理 1. 进程建立过程 fork()： 复制父进程上下文生成子进程，返回子进程 PID（父进程）和 0（子进程）。 exec()： 加载新程序覆盖当前进程空间（不生成新进程）。 2. 进程状态转换 UNIX 进程状态： 运行态（用户态/内核态）、就绪态、睡眠态（可中断/不可中断）、僵死态（Zombie）。 状态转换触发： 系统调用（如 read() 导致阻塞）、信号处理（如 SIGKILL 终止进程）。 3. 进程控制相关系统调用 系统调用 功能 fork() 创建子进程，继承父进程上下文。 exec() 加载新程序覆盖当前进程。 wait() 父进程阻塞，等待子进程终止。 exit() 终止当前进程，释放资源。 Q\u0026amp;A Q1: 什么是原语？为什么进程控制需要原语？\nA：原语是原子操作的指令集合，不可分割执行。进程控制需保证操作的完整性（如创建进程时分配 PCB 和资源必须一次性完成），避免因中断导致系统状态不一致。\nQ2: fork() 和 exec() 的区别是什么？\nA：\nfork() 会复制父进程生成新进程，子进程与父进程独立执行。 exec() 加载新程序覆盖当前进程，不生成新进程，仅替换代码段和数据段。 Q3: 进程阻塞和挂起的区别是什么？\nA：\n阻塞：进程因等待事件（如 I/O）留在内存，状态为阻塞。 挂起：进程被移至外存，状态为挂起（如就绪挂起、阻塞挂起）。 Q4: UNIX 中 Zombie 进程是如何产生的？\nA：当进程终止但父进程未调用 wait() 回收其资源时，PCB 仍保留在系统中，形成僵死进程。\nQ5: 激活原语的操作步骤是什么？\nA：\n将进程从外存移回内存； 更新状态为就绪态或阻塞态； 若就绪，加入就绪队列等待调度。 ","date":"2025-03-22T22:34:32+08:00","permalink":"https://rooobeam.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86ppt%E6%80%BB%E7%BB%93/","title":"操作系统原理PPT总结"},{"content":"存储方式 （未接入任何数据库）\nStore in Json KV Stroge\n最终生成的文件如下，随后分析整个流程每步生成了哪个文件，如何生成内容，文件结构如何。\nA[新文档] \u0026ndash;\u0026gt; B[文本分块]\nB \u0026ndash;\u0026gt; C[块向量存储]\nC \u0026ndash;\u0026gt; D[实体关系抽取]\nD \u0026ndash;\u0026gt; E[知识图谱更新]\nE \u0026ndash;\u0026gt; F[持久化存储]\nkv store doc status.json\nkv store full docs.json\nkv store Ilm response cache.json\nkv store text chunks.json\nvdb chunks.json\nvdb entities.json\nvdb relationships.json\n问题：\nchunk_overlap_token_size是什么？\n1 chunk_overlap_token_size: int = 100 # 分块重叠token数 ","date":"2025-03-20T22:09:22+08:00","permalink":"https://rooobeam.github.io/p/lightrag1.0.3%E8%A7%A3%E8%AF%BB/","title":"Lightrag1.0.3解读"},{"content":"Window系统和安全 实验平台为win2008，部分比对win11。\nWindows 账户、账户口令、文件系统、审核、日志、数据加密EFS、安全模板\n账户 计算机 右键 —— 管理 —— 配置 —— 本地用户和组 —— 用户 —— 点击具体用户 右键 —— 属性\n可勾选 “用户不能更改密码”“密码永不过期”“账户已禁用”\n账户策略 开始 |_管理工具 |_本地安全策略 |_账户策略 |_密码策略 |_账户锁定策略 |_本地策略 |_安全选项\n账户策略-密码策略 ​\t对每个策略右键 —— 属性 —— 可选启用or禁用，可查看 说明 选项卡\n​\t策略有：密码复杂性要求、长度要求、最短使用期限（防修改）、最长使用期限（防长期密码不更新）、强制密码历史（记录个数控制）、加密存储。\n账户策略-账户锁定策略 ​\t对每个策略右键 —— 属性 —— 可选启用or禁用，可查看 说明 选项卡\n​\t账户锁定时间（上锁后多久解锁）、锁定阈值（几次错误后上锁）、重置锁定计数器（多久后错误数变回0）\n本地策略-安全选项 不自动显示上次登录的账户\n​\t启用策略中： “交互式登录：不显示最后的用户名”\n禁止枚举账户名\n​\t禁止远程用户通过空连接枚举处所有本地账户名\n​\t启用策略中：“网络访问：不允许SAM账户和共享的匿名枚举”\n文件系统安全设置 加密数据 ​\tNTFS磁盘中文件，administrator用户下，新建文件夹，新建txt并写点。\n​\t文件夹右键 —— 常规 —— 高级 —— 勾选“加密内容以便保护数据”\n​\t用新建用户进入，发现无法打开文件夹\nEFS证书 开始 |_运行 |_mmc |_文件 |_t添加/删除管理单元 |_证书\nadministrator生成证书 ​\t回到administrator用户下，按照树流程找到证书，添加，勾选“我的用户账户”（生成当前用户的证书）\n​\t在控制台界面，按照以下树找到，注意！要先用了EFS加密了数据才会有，当然了如果用了其他软件加密也可能会有，因为这样加密后才会在 个人 下 生成证书。\n控制台根节点 |_证书 |_个人 |_证书 对界面中仅有的证书（因为没用其他软件加密过）,右键 —— 所有任务 —— 导出\n​\t勾选导出私钥，输入密码123123，选择D盘根目录下，文件名123123\ntest导入证书 ​\t换test用户，运行-mmc 打开控制台，添加/删除管理单元，添加证书。\n​\t到 控制台根节点-证书-个人，空白处右键，所有任务-导入，选择administrator导出保存的证书，输入密码123123，一直默认到完成，发现可以打开文件了。\n","date":"2025-03-20T19:16:41+08:00","permalink":"https://rooobeam.github.io/p/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/","title":"Windows操作系统安全"},{"content":"项目 目的 极简版 得到 文本块，处理为 实体 和 关系\na. 文本块（chunks） 文本内容：\u0026ldquo;Alice and Bob are collaborating on quantum computing research.\u0026rdquo; 来源id：doc-1 b. 实体（entities） 实体名称 类型 描述 来源 Alice person 量子物理领域的研究员 doc-1 Bob person 数学家 doc-1 Quantum Computing technology 利用量子力学现象进行计算的技术 doc-1 c. 关系（relationships） 关系编号 起点（src_id） 终点（tgt_id） 描述 关键词 权重 来源 1 Alice Bob Alice和Bob是研究伙伴 collaboration, research 1.0 doc-1 2 Alice Quantum Computing Alice从事量子计算研究 research, expertise 1.0 doc-1 3 Bob Quantum Computing Bob研究量子计算的应用 research, application 1.0 doc-1 项目结构 边看边更新\nLightRAG-main |__examples |\t|__lightrag_ollama_demo.py | |__lightrag |\t|__ kg |\t|\t|__ json_kv_impl.py |\t| |\t|__ __init__.py |\t|__ base.py |\t|__ lightrag.py |\t|__ utils.py | | |__setup.py | |\nmain()开始\t（lightrag_ollama_demo.py）\nmain()内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def main(): # Initialize RAG instance rag = asyncio.run(initialize_rag()) # Insert example text with open(\u0026#34;./book.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: rag.insert(f.read()) # Test different query modes print(\u0026#34;\\nNaive Search:\u0026#34;) print( rag.query( \u0026#34;What are the top themes in this story?\u0026#34;, param=QueryParam(mode=\u0026#34;naive\u0026#34;) ) ) print(\u0026#34;\\nLocal Search:\u0026#34;) print( rag.query( \u0026#34;What are the top themes in this story?\u0026#34;, param=QueryParam(mode=\u0026#34;local\u0026#34;) ) ) print(\u0026#34;\\nGlobal Search:\u0026#34;) print( rag.query( \u0026#34;What are the top themes in this story?\u0026#34;, param=QueryParam(mode=\u0026#34;global\u0026#34;) ) ) print(\u0026#34;\\nHybrid Search:\u0026#34;) print( rag.query( \u0026#34;What are the top themes in this story?\u0026#34;, param=QueryParam(mode=\u0026#34;hybrid\u0026#34;) ) ) # stream response resp = rag.query( \u0026#34;What are the top themes in this story?\u0026#34;, param=QueryParam(mode=\u0026#34;hybrid\u0026#34;, stream=True), ) if inspect.isasyncgen(resp): asyncio.run(print_stream(resp)) else: print(resp) 初始化: rag = asyncio.run(initialize_rag()) 进入initialize_rag()，\t（lightrag_ollama_demo.py）\n1 2 3 4 5 async def initialize_rag(): rag = LightRAG(...........)\tawait rag.initialize_storages() await initialize_pipeline_status() return rag rag = LightRAG(\u0026hellip;\u0026hellip;\u0026hellip;..) （lightrag_ollama_demo.py）\n初始化 LightRAG的对象 各个属性，主要是llm_model_X和embedding_func，两个模型均由本例ollama提供\n显式传入的参数是__init__里的，它还有__post_init__。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 rag = LightRAG(\t# lightrag_ollama_demo.py - line 22 working_dir=WORKING_DIR, llm_model_func=ollama_model_complete, llm_model_name=\u0026#34;deepseek-r1:7b\u0026#34;, llm_model_max_async=4, llm_model_max_token_size=32768, llm_model_kwargs={ \u0026#34;host\u0026#34;: \u0026#34;http://localhost:6006\u0026#34;,\t# 本地ollama提供服务的端口为6006 \u0026#34;options\u0026#34;: {\u0026#34;num_ctx\u0026#34;: 32768}, }, embedding_func=EmbeddingFunc( embedding_dim=768, max_token_size=8192, func=lambda texts: ollama_embed( texts, embed_model=\u0026#34;nomic-embed-text\u0026#34;, host=\u0026#34;http://localhost:6006\u0026#34; ), ), ) await rag.initialize_storages() （lightrag_ollama_demo.py）\n每个storages的初始化都类似，其父类都时base里的Base\u0026hellip;Storage\nkg文件夹里的 各种_impl里定义具体的子类（如JsonDocStatusStorage） 继承了父类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 async def initialize_storages(self):\t# lightrag.py - line 456 \u0026#34;\u0026#34;\u0026#34;Asynchronously initialize the storages\u0026#34;\u0026#34;\u0026#34; # StoragesStatus.CREATED即\u0026#39;created\u0026#39; str # self._storages_status什么时候定义的？默认值？ # 答：__post_init__里定义的。 # __post_init__ 是 @dataclass 提供的一个特殊方法 # \u0026#34;第二初始化\u0026#34;，在自动__init__后执行 # 用于在对象初始化完成后执行额外的操作。 # post 是拉丁语前缀，表示“在……之后” if self._storages_status == StoragesStatus.CREATED: tasks = [] # ====== 此时跳到下一个三级标题查看__post_init__的内容 ====== for storage in ( self.full_docs, self.text_chunks, self.entities_vdb, self.relationships_vdb, self.chunks_vdb, self.chunk_entity_relation_graph, self.llm_response_cache, self.doc_status, ): if storage: # 每个存储模块的初始化 tasks.append(storage.initialize()) await asyncio.gather(*tasks) # 修改self._storages_status self._storages_status = StoragesStatus.INITIALIZED logger.debug(\u0026#34;Initialized Storages\u0026#34;) __post_init__ （lightrag.py）\n由于使用了@dataclass，故__init__自动实现了，而要内部再init则用__post_init__\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def __post_init__(self): from lightrag.kg.shared_storage import ( initialize_share_data, ) ... # Initialize all storages self.key_string_value_json_storage_cls: type[BaseKVStorage] = self._get_storage_class(self.kv_storage) # type: ignore self.vector_db_storage_cls: type[BaseVectorStorage] = self._get_storage_class( self.vector_storage ) # type: ignore self.graph_storage_cls: type[BaseGraphStorage] = self._get_storage_class( self.graph_storage ) # type: ignore self.key_string_value_json_storage_cls = partial( # type: ignore self.key_string_value_json_storage_cls, global_config=global_config ) ... # line 429 self._storages_status = StoragesStatus.CREATED 这里初始化了各个组件的，调用各种模块\n就拿self.full_docs举例而言，它是 BaseKVStorage的实例化，该实例的初始化，由key_string_value_json_storage_cls 类 传入 namespace和embedding_func返回\ninitialize_pipeline_status() （shared_storage.py）\n初始化pipeline的各种状态值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 async def initialize_pipeline_status(): \u0026#34;\u0026#34;\u0026#34; Initialize pipeline namespace with default values. This function is called during FASTAPI lifespan for each worker. \u0026#34;\u0026#34;\u0026#34; pipeline_namespace = await get_namespace_data(\u0026#34;pipeline_status\u0026#34;) # _manager.list() async with get_internal_lock(): # 通过检查必要字段，判断是否已经初始化 if \u0026#34;busy\u0026#34; in pipeline_namespace: return # Create a shared list object for history_messages history_messages = _manager.list() if is_multiprocess else [] pipeline_namespace.update( { \u0026#34;busy\u0026#34;: False, # Control concurrent processes \u0026#34;job_name\u0026#34;: \u0026#34;Default Job\u0026#34;, # Current job name (indexing files/indexing texts) \u0026#34;job_start\u0026#34;: None, # Job start time \u0026#34;docs\u0026#34;: 0, # Total number of documents to be indexed \u0026#34;batchs\u0026#34;: 0, # Number of batches for processing documents \u0026#34;cur_batch\u0026#34;: 0, # Current processing batch \u0026#34;request_pending\u0026#34;: False, # Flag for pending request for processing \u0026#34;latest_message\u0026#34;: \u0026#34;\u0026#34;, # Latest message from pipeline processing \u0026#34;history_messages\u0026#34;: history_messages, # 使用共享列表对象 } ) direct_log(f\u0026#34;Process {os.getpid()} Pipeline namespace initialized\u0026#34;) 插入: rag.insert(f.read()) rag.insert(f.read())\n​\t-\u0026gt; self.ainsert(input)\n​\t-\u0026gt; self.apipeline_enqueue_documents\n​\t-\u0026gt; self.apipeline_process_enqueue_documents\n进入rag.insert内 rag.insert(f.read()) -\u0026gt; 转到 self.ainsert(input)，input即 f.read()（字符串），\n1 2 3 4 5 6 7 8 9 10 11 12 13 def insert( self, input: str | list[str], split_by_character: str | None = None, split_by_character_only: bool = False, ids: str | list[str] | None = None, ) -\u0026gt; None: # 创建事件循环，然后把self.ainsert加入循环，执行时传入input，其他参数都默认 loop = always_get_an_event_loop() loop.run_until_complete( self.ainsert(input, split_by_character, split_by_character_only, ids) ) 进入self.ainsert内 两个内容，一个是 添加 文档状态信息，另一个是 处理文档\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 async def ainsert( self, input: str | list[str], split_by_character: str | None = None, split_by_character_only: bool = False, ids: str | list[str] | None = None, ) -\u0026gt; None: # 将input，即文档或list of 文档 的status信息加入doc_status数据库 await self.apipeline_enqueue_documents(input, ids) # 处理文档，创建知识库的主要部分 await self.apipeline_process_enqueue_documents( split_by_character, split_by_character_only ) self.apipeline_enqueue_documents ","date":"2025-03-20T00:00:00Z","permalink":"https://rooobeam.github.io/p/lightrag1.2.6%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/","title":"Lightrag1.2.6代码解读"},{"content":"Tree Search 目录结构 - - - - 一、翻转树 二、相同树 三、层序遍历并标序 四、对称树 五、二叉树的最大深度 六、二叉树的最小深度 七、路径总和 八、二叉树层序遍历无标序号 九、岛屿的周长 十、左叶子之和 十一、二叉搜索树的最小绝对差 十二、二叉树层序遍历II 十三、合并二叉树 十四、二叉树的层平均值 十五、找出克隆二叉树中的相同节点 十六、图像渲染 [十七、N 叉树的最大深度](#十七N 叉树的最大深度) 十八、单值二叉树 十九、二叉树的堂兄弟节点 队列的运用：一、二、\n一、翻转树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def invertTree(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: # 排除root为空的情况 if not root: return root # 队列 \u0026lt;——\u0026gt; list que=[root]\t# 循环条件：队列不为空 while que: # 出队 tnode=que.pop(0) # 如果左子树存在，入队 if tnode.left: que.append(tnode.left) # 如果右子树存在，入队 if tnode.right: que.append(tnode.right) # 将开头出队的左右子树换位 a=tnode.right tnode.right=tnode.left tnode.left=a return root #关键在于，队列初始化、出入队操作，以及存在才入队。 二、相同树 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -\u0026gt; bool: p_ls=[p] q_ls=[q] while(p_ls): p_n=p_ls.pop(0) q_n=q_ls.pop(0) if (p_n is None and q_n is not None or q_n is None and p_n is not None): return False if p_n: if p_n.val!=q_n.val: return False p_ls.append(p_n.left) p_ls.append(p_n.right) q_ls.append(q_n.left) q_ls.append(q_n.right) return True 三、层序遍历并标序（自定义）（通解性） 此题为自定义的，具有通解性质，可暴力解决很多题目。\n给你一个二叉树的根节点 root ，一层一层地打印并标明位置，包括空结点。\n关键是通过上层序号，向左子树走+0，向右子树走+1\n(root,0) |\t\\\t|\t(left,0) (right,1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 在 104. 二叉树的最大深度 测试的 class Solution: def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: print(root) return # 初始化队列 q = [(root, 0)] while q: # 遍历当前层 for _ in range(len(q)): tnode=q.pop(0) # (root,0) (Treenode,int) if tnode[0]: q.append((tnode[0].left,tnode[1]*2+0)) q.append((tnode[0].right,tnode[1]*2+1)) if tnode[0]: print(tnode[0].val,tnode[1],end=\u0026#39;\\t\u0026#39;) else: print(tnode[0], tnode[1],end=\u0026#39;\\t\u0026#39;) print() return 四、对称树 给你一个二叉树的根节点 root ， 检查它是否轴对称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 # 暴力标出行点位 # 变量说明 # q: que 队列\tcnt: 记录某层存在的结点的个数\tn_lay: 当前层总位置数，即2^k个，k=0,1,2... # n: 当前层未分析的结点个数，初始为cnt，然后-1-1-1... # cp_cnt: 记录当前层的结点总个数，初始和n一样，只不过不会变化 # stack: 栈，进栈一半结点后，开始分析对称性时，通过出栈互消除 class Solution: def isSymmetric(self, root: Optional[TreeNode]) -\u0026gt; bool: if not root: return True q=[(root,0)]\t# 队列 cnt=1 # 初始化第一层要分析的结点数 n_lay=1 # 当前层的位置总个数 while(q): n=cnt # 该层 还要 分析结点数，不停地减一 cp_cnt=cnt # 该层 结点总数 cnt=0 # 清零保存下层结点数 stack=[] # 遍历当前层 while (n): tnode=q.pop(0) if n\u0026lt;=cp_cnt/2: # 出栈 pop_node=stack.pop(-1) # 都是真，核对位置和值 if tnode[0] and pop_node[0]: if tnode[0].val!=pop_node[0].val: print(\u0026#39;A\u0026#39;) return False if (tnode[1]+pop_node[1])!=n_lay-1: print(\u0026#39;B\u0026#39;) return False # 排除了都是真，但不都None，则必为一真一None elif tnode[0] or pop_node[0]: print(\u0026#39;C\u0026#39;) return False else: # 都是None，核对位置 if (tnode[1]+pop_node[1])!=n_lay-1: print(\u0026#39;D\u0026#39;) return False # 都是None则已经出栈完成互消 else: stack.append(tnode) if tnode[0]: q.append((tnode[0].left,tnode[1]*2+0)) q.append((tnode[0].right,tnode[1]*2+1)) cnt+=2 n-=1 n_lay*=2 return True 1 2 3 4 5 6 7 8 9 # 递归 class Solution: def isSymmetric(self, root: Optional[TreeNode]) -\u0026gt; bool: def recur(L, R): if not L and not R: return True if not L or not R or L.val != R.val: return False return recur(L.left, R.right) and recur(L.right, R.left) return not root or recur(root.left, root.right) 五、二叉树的最大深度 104. 二叉树的最大深度 - 力扣（LeetCode）\n给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n两种思路：自顶向下 和 自底向上\n自顶向下：顶层为1，向下加一并取最大返回 1 2 3 4 5 6 7 8 9 10 # 自顶向下 class Solution: def recur(self,tnode:Optional[TreeNode],dep:int)-\u0026gt;int: if not tnode: return dep-1 else: return max(self.recur(tnode.left, dep+1), self.recur(tnode.right, dep+1)) def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: return self.recur(root,1) 自底向上：最底空结点为0，一直向上加，太惊艳了 “我在网上看到一种理解递归的说法：「在写递归函数时，可以假设递归返回的结果一定是正确的」。其实这种说法本质上就是数学归纳法。”——作者\n代码中 max(l_depth, r_depth) + 1 就是假设l_depth 和 r_depth是正确的，然后本层则为 max(l_depth, r_depth) + 1\n​\tif root is None: ​ return 0 ​ l_depth = self.maxDepth(root.left) ​ r_depth = self.maxDepth(root.right) 则保证了初始状况也是正确的，刚才的假设便成立，就能得到正确结果。\nhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/2010612/kan-wan-zhe-ge-shi-pin-rang-ni-dui-di-gu-44uz/\n1 2 3 4 5 6 # 自底向上 class Solution: def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right))+1 六、二叉树的最小深度 给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n**说明：**叶子节点是指没有子节点的节点。\n111. 二叉树的最小深度 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: return 0 # root此时必为True return self.recur(root) def recur(self, root: Optional[TreeNode]) -\u0026gt; int: # 俩子节点都为False if not (root.left or root.right): return 1 # 俩子节点都为True elif root.left and root.right: return min(self.recur(root.left),self.recur(root.right))+1 # 1 True 1 False else: return self.recur(root.left)+1 if root.left else self.recur(root.right)+1 七、路径总和 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n叶子节点 是指没有子节点的节点。\n112. 路径总和 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: global t_sum t_sum=targetSum if not root: return False # root一定为True了 return self.recur(root,0) def recur(self,root: Optional[TreeNode], pre_sum: int) -\u0026gt; bool: global t_sum cur_sum=pre_sum+root.val # 俩空子节点 if not (root.left or root.right): if cur_sum == t_sum: return True else: return False # 俩非空子节点 elif root.left and root.right: return self.recur(root.left,cur_sum) or self.recur(root.right,cur_sum) # 一空一非空 else: return self.recur(root.left,cur_sum) if root.left else self.recur(root.right,cur_sum) 八、二叉树层序遍历无标序号 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n“三、层序遍历并标序”的简单版。\n102. 二叉树的层序遍历 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: # 保证root有val if not root: return [] q=[root] nodes=[] # 全部遍历（相对层内而言） while(q): tmp=[] # 层内遍历 for _ in range(len(q)): tnode=q.pop(0) tmp.append(tnode.val) if(tnode.left): q.append(tnode.left) if(tnode.right): q.append(tnode.right) nodes.append(tmp) return nodes 九、岛屿的周长 岛屿的周长\n给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。\n网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n1 2 3 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] 输出：16 解释：它的周长是上面图片中的 16 个黄色的边 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 不用检查每个土格四周是否也是土格子，因为a格子右边是b格子， # 则b格子左边必然是a格子，只需检查每个格子的左上即可 class Solution: def islandPerimeter(self, grid: List[List[int]]) -\u0026gt; int: # 定义行数、列数和周长 row=len(grid) col=len(grid[0]) sum=0 # row_ls: row list\te: element for i,row_ls in enumerate(grid): for j,e in enumerate(row_ls): # 如果是地 if e: sum+=4 # 检查左方格是否为土，首先排除向左超边界 if j!=0 and grid[i][j-1]: sum-=2 # 检查上方格是否为土，首先排除向上超边界 if i!=0 and grid[i-1][j]: sum-=2 return sum 十、左叶子之和 404. 左叶子之和 - 力扣（LeetCode）\n给定二叉树的根节点 root ，返回所有左叶子之和。\n1 2 3 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: return 0 def recur(root: Optional[TreeNode], flag: bool) -\u0026gt; int: # 为叶子结点 if not(root.left or root.right): if flag: return root.val else: return 0 # 都非空 elif root.left and root.right: return recur(root.left, True)+recur(root.right, False) # 一个非空一个空 else: return recur(root.left, True) if root.left else recur(root.right, False) # recur函数要在定义后调用 return recur(root, False) 十一、二叉搜索树的最小绝对差 530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）\n给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n差值是一个正数，其数值等于两值之差的绝对值。\nWhat I learn:\n类里的全局变量——类属性（见 十九 ，嵌套函数里声明外部变量 nonelocal） 调用类的属性、方法都要“self.” “self.” “self.” !!! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def __init__(self): self.dif=inf self.pre=-inf def getMinimumDifference(self, root: Optional[TreeNode]) -\u0026gt; int: if root.left: self.getMinimumDifference(root.left) self.dif=min(self.dif, root.val-self.pre) self.pre=root.val if root.right: self.getMinimumDifference(root.right) return self.dif 十二、二叉树层序遍历II 107. 二叉树的层序遍历 II - 力扣（LeetCode）\n给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrderBottom(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if not root: return [] q=[root] nodes=[] while(q): tmp=[] for _ in range(len(q)): tnode=q.pop(0) tmp.append(tnode.val) if tnode.left: q.append(tnode.left) if tnode.right: q.append(tnode.right) nodes.append(tmp) return nodes[::-1] 十三、合并二叉树 617. 合并二叉树 - 力扣（LeetCode）\n**递归：1. 假定往下传一些参数，他能返回理想值，2. 当前层，接收了上层参数，确保能返回理想值。**具体看代码注释，关键是 “处理好当前层内容，正确返回上层”\n给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: # ===== 当前层，接收了上层参数，确保能返回理想值 ===== # 都为空传回空 if root1 is None and root2 is None: return None # 否则必有一个非空 # 一个非空传回 非空那个 if root1 is None: return root2 if root2 is None: return root1 # 否则必然都非空 # 都非空，不return，加和当前结点值，继续往下执行 root1.val+=root2.val # ===== 假定往下传一些参数，他能返回理想值 ===== root1.left=self.mergeTrees(root1.left,root2.left) root1.right=self.mergeTrees(root1.right,root2.right) return root1 十四、二叉树的层平均值 637. 二叉树的层平均值 - 力扣（LeetCode）\n给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution: def averageOfLevels(self, root: Optional[TreeNode]) -\u0026gt; List[float]: if not root: return [] q=[root] ave=[] while(q): tmp=0.0\t#当前层的和 q_len=len(q)\t# 当前层长度 for _ in range(q_len): tnode=q.pop(0) tmp+=tnode.val if tnode.left: q.append(tnode.left) if tnode.right: q.append(tnode.right) ave.append(tmp/q_len) return ave 十五、找出克隆二叉树中的相同节点 1379. 找出克隆二叉树中的相同节点 - 力扣（LeetCode）\n给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original 中的目标节点 target。\n其中，克隆树 cloned 是原始树 original 的一个 副本 。\n请找出在树 cloned 中，与 target 相同 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。\nWhat I have leaned:\n声明全局变量 未必比 传形参要好，因为python都是传引用，除非对其修改 才可能 创建副本 TreeNode可以直接进行比较，实际比较的是 物理内存地址（指针），target和original指到同一处时，original is target才为True，cloned is target永远为False 1 2 3 4 5 6 7 8 class Solution: def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -\u0026gt; TreeNode: if original is None or original is target: return cloned return self.getTargetCopy(original.left, cloned.left, target) or \\ self.getTargetCopy(original.right, cloned.right, target) 作者：灵茶山艾府 十六、图像渲染 733. 图像渲染 - 力扣（LeetCode）\n有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。你也被给予三个整数 sr , sc 和 color 。你应该从像素 image[sr][sc] 开始对图像进行上色 填充 。\n为了完成 上色工作：\n从初始像素开始，将其颜色改为 color。 对初始坐标的 上下左右四个方向上 相邻且与初始像素的原始颜色同色的像素点执行相同操作。 通过检查与初始像素的原始颜色相同的相邻像素并修改其颜色来继续 重复 此过程。 当 没有 其它原始颜色的相邻像素时 停止 操作。 最后返回经过上色渲染 修改 后的图像 。\nwhat you learn:\n初始像素与目标颜色相同。不会对图像进行任何更改。 找一种中序遍历的感觉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -\u0026gt; List[List[int]]: q=[(sr,sc)] r_len=len(image) c_len=len(image[0]) # original color ori_c=image[sr][sc] if ori_c==color: return image while(q): # element e=q.pop(0) # current block\u0026#39;s color image[e[0]][e[1]]=color # 上:行不为0 if e[0] and image[e[0]-1][e[1]] == ori_c: q.append((e[0]-1, e[1])) # 左：列不为0 if e[1] and image[e[0]][e[1]-1] == ori_c: q.append((e[0], e[1]-1)) # 下：行不为r_len-1 if e[0]!=r_len-1 and image[e[0]+1][e[1]] == ori_c: q.append((e[0]+1, e[1])) # 右：列不为c_len-1 if e[1]!=c_len-1 and image[e[0]][e[1]+1] == ori_c: q.append((e[0], e[1]+1)) return image 十七、N 叉树的最大深度 559. N 叉树的最大深度 - 力扣（LeetCode）\n给定一个 N 叉树，找到其最大深度。\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\nWhat I learn:\n不要掉入惯性思维的坑，仔细看它定义的类（结构体）是怎样的，此题没有空结点（对比 二叉树最大深度 的 定义，它不是子树结点为None而是存子树的list为None，因此，无法实现 “当前结点为None”这种做法。 这就引出在递归结尾处的两种处理，一种是“如果子树不为空，才进入递归函数”，另一种是“子树结点传进递归函数，函数开头判断是否为空”，我称前者为“预判处理”，后者为“当前层处理”。二者看情况用，通常用“当前层处理”，但这里不行，因为没有 空结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026#34;\u0026#34;\u0026#34; # Definition for a Node. class Node: def __init__(self, val: Optional[int] = None, children: Optional[List[\u0026#39;Node\u0026#39;]] = None): self.val = val self.children = children \u0026#34;\u0026#34;\u0026#34; class Solution: def maxDepth(self, root: \u0026#39;Node\u0026#39;) -\u0026gt; int: if not root: # 注意函数返回值限制为int类型 return 0 # 注意不是从空结点层向上返回的，故不是从0开始 return \\ max([self.maxDepth(node) for node in root.children])+1 \\ if root.children else 1 十八、单值二叉树 965. 单值二叉树 - 力扣（LeetCode）\n如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。\n只有给定的树是单值二叉树时，才返回 true；否则返回 false。\nWhat I learn:\n方法里定义的临时变量（代码里的 v ），对于方法里的函数（哪怕递归了）是全局的。\n—— 当dfs被定义为嵌套函数时，它可以访问外部函数isUnivalTree中的变量v（闭包机制）\n—— 如果将dfs改为实例方法（如self.dfs），则需通过实例属性（如self.v）来共享变量\n如果有多个、多重if else，看看能不能用 or and 代替\n定义参数时不要和外边变量重名，如：def dfs(node): 而非 def dfs(root):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isUnivalTree(self, root: TreeNode) -\u0026gt; bool: # 变量v对于dfs是全局的 v = root.val def dfs(node): return node is None or \\ (node.val == v and dfs(node.left) and dfs(node.right)) return dfs(root) 作者：Benhao \u0026#39;\u0026#39;\u0026#39; return node is None or \\ (node.val == v and dfs(node.left) and dfs(node.right)) ===== 等价于 ===== if not root: return True if root.val==self.n: return self.recur(root.left) and self.recur(root.right) else: return False \u0026#39;\u0026#39;\u0026#39; 十九、二叉树的堂兄弟节点 993. 二叉树的堂兄弟节点 - 力扣（LeetCode）\n在二叉树中，两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\nWhat I learn:\n当你想得清楚当前层的处理时，发现要上层数据，想想能不能传递上层数据下去\n嵌套函数 对 外部作用域变量的访问 的关键区别：读取和修改。\n只要函数内部存在对变量 pre_dep 的 修改（如 pre_dep = dep），Python 默认将其视为 局部变量。\n仅读取，则会视为外部变量（见 十八 的 v）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 当你想得清楚当前层的处理时，发现要上层数据，想想能不能传递上层数据下去 class Solution: def isCousins(self, root: Optional[TreeNode], x: int, y: int) -\u0026gt; bool: if root.val==x or root.val==y: return False pre_dep=0 pre_par=None def recur(root, dep, par): nonlocal pre_dep, pre_par if not root: return False # 如果有一个值对上了，说明遇上了一个结点 if root.val==x or root.val==y: # 如果pre_dep不为0，前者已找到，必须深度一样且父节点不同 if pre_dep: return dep==pre_dep and par is not pre_par else: pre_dep=dep pre_par=par return recur(root.left, dep+1, root) or\\ recur(root.right, dep+1, root) return recur(root.left, 1, root) or \\ recur(root.right, 1, root) ","date":"2025-03-19T00:00:00Z","permalink":"https://rooobeam.github.io/p/tree_search/","title":"Tree_search"},{"content":".pop(self,index)方法 1 2 3 a=[1,2,3] a.pop(1) print(a)\t# [1,3] 函数传实参还是形参问题 在 Python 中，参数传递始终是 引用传递（传地址的）。但根据对象类型（可变/不可变）的不同，会产生类似「值传递」或「引用传递」的表象：\n结论：看对象类型\n不可变对象（字符串、数字、元组等）作为参数时： 形参接收到的是对象的引用 若在函数内修改形参，会创建新对象，实参不受影响（类似值传递） 可变对象（列表、字典、集合等）作为参数时： 形参接收到的也是对象的引用 若在函数内 原地修改 形参（如 append、+= 等操作），实参会同步变化（类似引用传递） 1 2 3 4 5 6 7 8 9 10 11 12 13 def f(obj): # 修改形参 obj += obj # 不可变对象（字符串） obj1 = \u0026#34;123456\u0026#34; demo(obj1) print(\u0026#34;函数调用后obj1:\u0026#34; + obj1) # 123456（未变） # 可变对象（列表） obj2 = [1,2,3] demo(obj2) print(\u0026#34;函数调用后obj2:\u0026#34; + str(obj2)) # [1,2,3,1,2,3]（已变） pychram 来回查看代码 pycharm会用ctrl+鼠标左键点击函数来进入函数体查看函数具体实现部分。但是我常常点击后就回不来了，不同文件的函数调用来回找让人头大。\n可以来回的方法是：\nctrl+alt+左方向键(←) 后退(回退回原来位置, 不行就多摁几次，因为光标点击的地方好像也会记录)\nctrl+alt+右方向键(→) 前进(即回到刚才点击的函数位置)\n参考链接：https://blog.csdn.net/shmily_ke/article/details/136975710\nfor _ in range(len(queue)) 下划线 \u0026lsquo;_\u0026rsquo;：_ 是一个占位符，表示“我不关心这个索引值”\nlen(queue)忽略循环中queue本身的变化\n特性 for _ in range(len(queue)) for _ in queue 遍历方式 基于索引，范围固定 动态跟踪变化 q 增加元素 不会遍历到新添加的元素 可能会遍历到新添加的元素 **q 删除元素 ** 可能导致索引越界 可能导致跳过元素或提前结束 103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）\n对比我的代码和题解代码如下：\n我的还要用cnt记录下一层的结点个数，它只需要for _ in range(len(queue))中的len(queue)就能保留一层的值然后循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def zigzagLevelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if not root: return [] res, queue = [], collections.deque() queue.append(root) while queue: tmp = [] for _ in range(len(queue)): node = queue.popleft() tmp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res.append(tmp[::-1] if len(res) % 2 else tmp) return res 链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/solutions/2361613/103-er-cha-shu-de-ju-chi-xing-ceng-xu-bi-qz2q/ 部分 可迭代型数据 逆序 list.reverse() reversed(iterable) list[::-1]——需要对象有__getitem__，最好用 特性 reverse() reversed() [::-1] ‌功能‌ 原地反转列表 返回反转后的迭代器 返回反转后的新对象 ‌适用对象‌ 仅列表（list） 所有可迭代对象（列表、元组、字符串等） 所有支持切片的有序序列（列表、字符串、元组等） ‌返回值‌ None 迭代器 反转后的新对象 ‌内存效率‌ 高（原地操作，不生成新对象） 高（返回迭代器，不生成完整副本） 低（生成完整副本，占用额外内存） ‌时间复杂度‌ O(n)（直接交换元素） O(1)（延迟计算，实际遍历时 O(n)） O(n)（复制所有元素） ‌修改原数据‌ ✅ 是 ❌ 否 ❌ 否 ‌支持链式操作‌ ❌ 否（返回 None） ✅ 是（可与 list()、join() 等结合） ✅ 是（直接生成新对象） for key in dic_1 if key in dic_2 1 2 3 4 5 6 dic_1={\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3} dic_2={\u0026#39;b\u0026#39;:2} dic_3 = { key: dic_1[key] for key in dic_1 if key in dic_2 } print(dic_3)\t# {\u0026#39;b\u0026#39;: 2} 声明多个全局变量\n逗号 隔开，“ \\ ”连接下一行\n1 2 3 4 5 6 7 8 9 10 global \\ _manager, \\ is_multiprocess, \\ _storage_lock, \\ _internal_lock, \\ _pipeline_status_lock, \\ _shared_dicts, \\ _init_flags, \\ _initialized, \\ _update_flags 字典 .join方法 dataclasses dataclasses 的 dataclass, field\npycharm书签功能 按 F11 对光标那行生成书签\npycharm关警告 右上角有 黄色三角形警告图标⚠ 直接鼠标放置⚠处 会自动显示 如 “25个警告，3个弱警告 高亮显示：所有问题” 点击 高亮显示：所有问题 弹出“无 语法 所有问题”，点击 无 即可。 ","date":"2025-03-18T00:00:00Z","permalink":"https://rooobeam.github.io/p/py_coding_tricks/","title":"Py_coding_tricks"},{"content":"较全面的教程参考：Linux Vim最全面的教程-阿里云开发者社区\n","date":"2025-03-14T16:52:54+08:00","permalink":"https://rooobeam.github.io/p/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","title":"Vim常用操作"},{"content":"自动git提交 .bat文件准备 新建txt，写入一下内容 1 2 3 4 5 6 7 8 9 10 11 12 @echo off REM 切换到 仓库所在目录 cd /d \u0026#34;D:\\github_blog\\\u0026#34; REM 执行 Git 命令 git add . git commit -m \u0026#34;update\u0026#34; git push REM 响应一下啦！ echo gooo_job! pause 另存为“所有文件(*)”，编码类型选择ANSI，命名为auto_git_commit.bat，放在如 D:/script 下。\n注意事项\ncd \\d \u0026ldquo;D:/\u0026rdquo; 一定要有双引号，否则找不到。\n如何记住哪个是转义字符的斜杠，哪个是目录的斜杠 tips: \\n\\t已记住，所以\\是转义，所以/是目录的\n命名文件夹、文件 不要有 空格 或 . . 开头会导致以为是 ‌**“点文件”（Dot Files）（隐藏文件）**如.bat\necho 后面的内容不要有空格，要连续\n编码格式要为ANSI，utf-8不行\n任务计划程序内创建基本任务 win+r 输入指令 taskschd.msc\t任务计划程序（Task Scheduler —— taskschd）\n打开(O):taskschd.msc\n最右侧一栏 找到 创建基本任务\n输入名称、描述\n希望该任务何时开始?\t——\t每天(D)\n填1，每隔1天发生一次\n希望该任务执行什么操作?\t——\t启动程序(T）\n程序或脚本(P):\t——\t点击浏览(R)，找到auto_git_commit.bat，如在 D:/script 下。\n完成\n创建新blog的 .bat文件 除了内容，其他和前者创建.bat文件一样\n用到hugo框架，故用hugo new content创建目录、文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @echo off setlocal enabledelayedexpansion :input_blog_name cls echo 请输入博客名称（不含空格，不要 . 开头）： set /p \u0026#34;blog_name=\u0026gt;\u0026gt; \u0026#34; REM 检查输入是否为空 if \u0026#34;%blog_name%\u0026#34;==\u0026#34;\u0026#34; ( echo 错误：博客名称不能为空！ timeout /t 2 /nobreak \u0026gt;nul goto input_blog_name ) REM 执行操作 cd /d \u0026#34;D:\\github_blog\\\u0026#34; hugo new content post/%blog_name%/index.md REM 结果反馈 if exist \u0026#34;D:\\github_blog\\\u0026#34; ( echo D:\\github_blog\\content\\post\\%blog_name%\\index.md 现已存在 ) pause ","date":"2025-03-13T21:36:27+08:00","permalink":"https://rooobeam.github.io/p/bat%E6%96%87%E4%BB%B6%E5%AE%9E%E9%AA%8C/","title":"bat文件实验"},{"content":"转移指令原理 offset 获得标号的偏移地址\n大小为一个字\n性质相当于表示IP的idata\njmp 标号 jmp short s\t短转移 jmp near s\t近转移 jmp far s\t远转移 寄存器/idata jmp reg/一字idata\njmp sreg:reg/一字idata:一字idata\n内存单元 jmp word ptr 内存地址\njmp dword ptr 内存地址\njcxz jump if (cx) == zero\n等价于if((cx)==0) jmp short 标号\t短转移\nloop 短转移类型\n(cx)\u0026ndash;\nif((cx)!=0)jmp short 标号\n实验8 实验9 ","date":"2025-03-12T00:05:02+08:00","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B9%9D%E7%AB%A0/","title":"汇编语言第九章"},{"content":"第十章 CALL 和 RET指令 ret、retf ret —— return\tretf —— return far\nret 出栈字单元 放入IP\n相当于 pop IP\nretf 第一次出栈 字单元 放入 IP，第二次出栈 字单元 放入CS，相当于\npop IP\npop CS\n栈里，CS总在IP底下\n|\t| | IP | | CS | |\u0026mdash;\u0026mdash;-|\n结合上地址来说，CS总在IP的右边（高地址），因为sp压栈会从高到低走。\nIP CS ​\t↑ ​\tsp\n出栈、压栈总是一个字单元\n实现从1000:0000处开始执行指令，谁知道1000:0000处有啥。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 assume cs:code stack segment db 16 dup (0) stack ends code segment start:\tmov ax, stack mov ss, ax mov sp, 16 mov ax, 1000h push ax mov ax, 00h push ax retf code ends call 标号型 call s (s是标号)（位移转移），将当前IP压入栈，然后近转移到s，相当于\npush IP\njmp near ptr s(标号)\n1000:3处指令为call s，s处内容为s:pop ax\n执行完这两条指令后，ax数值为 3\ncall far ptr s（标号），先将CS压入栈，再将IP压栈，然后远转移到s，相当于\npush CS\npush IP\njmp far ptr s(标号)\n寄存器型 call 16位reg，压栈IP，IP=(reg)\npush IP\njmp 16位reg\n内存单元型 call word ptr 内存单元地址，地址取出内容大小为字单元，仅压栈IP，相当于\npush IP\njmp word ptr 如es:[bx]\ncall dword ptr 内存单元地址，地址取出内容大小为双字，先压栈CS再压栈IP，相当于\npush CS\npush IP\njmp dword ptr 如es:[bx]\ncall和ret实现模块化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 assume cs:code stack segment db 8 dup (0) db 8 dup (0) stack ends code segment start: mov ax, stack mov ss, ax mov sp, 16 mov ax, 1000h call s mov ax, 4c00h int 21h s: add ax,ax ret code ends end start mul指令 ","date":"2025-03-12T00:03:22+08:00","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/","title":"汇编语言第十章"},{"content":"python调试 参考Linux 下如何调试 Python？ - hoxis - 博客园\n在命令行，将程序作为参数传递来调试，“\u0026hellip; -m pdb \u0026hellip;py”，—— 命令行传pdb方式\npython3 -m pdb test1.py\n1 2 3 4 root@autodl-container-c00844b981-267cf857:~/autodl-tmp/test_script# python3 -m pdb test1.py \u0026gt; /root/autodl-tmp/test_script/test1.py(3)\u0026lt;module\u0026gt;() -\u0026gt; def add(a, b): (Pdb) _\u0026lt;-光标在此处 在代码中import pdb，写pdb.set_trace()代码 —— import pdb 方式\nimport pdb\npdb.set_trace()\npython3 test1.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # -*- coding: utf-8 -*- import pdb def add(a, b): return a + b if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;===start===\u0026#34;) pdb.set_trace() c = add(1, 3) print(\u0026#34;===end===\u0026#34;) ======= 命令行情况如下 ======== root@autodl-container-c00844b981-267cf857:~/autodl-tmp/test_script# python3 test1.py ===start=== \u0026gt; /root/autodl-tmp/test_script/test1.py(9)\u0026lt;module\u0026gt;() -\u0026gt; c = add(1, 3) (Pdb) 进入调试后常用指令\n(Pdb) l\t（“小写L指令”：查看）（若连续输入两次，则第二次返回[EOF]）\n(Pdb) p 变量名\t（查看当前可查变量）\n(Pdb)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ===========\t命令行传pdb root@autodl-container-c00844b981-267cf857:~/autodl-tmp/test_script# python3 -m pdb test1.py \u0026gt; /root/autodl-tmp/test_script/test1.py(3)\u0026lt;module\u0026gt;() -\u0026gt; def add(a, b): (Pdb) 1 1 # -*- coding: utf-8 -*- 2 3 -\u0026gt; def add(a, b): 4 return a + b 5 6 if __name == \u0026#39;__main__\u0026#39;: 7 print(\u0026#34;==start==\u0026#34;) 8 c = add(1, 3) 9 print(\u0026#34;==end==\u0026#34;) [EOF] (Pdb) b 8 Breakpoint 1 at /root/autodl-tmp/test_script/test1.py:8 (Pdb) b 9 Breakpoint 2 at /root/autodl-tmp/test_script/test1.py:9 (Pdb) b Num Type Disp Enb Where 1 breakpoint keep yes at /root/autodl-tmp/test_script/test1.py:8 2 breakpoint keep yes at /root/autodl-tmp/test_script/test1.py:9 (Pdb) c ===start=== \u0026gt; /root/autodl-tmp/test_script/test1.py(8)\u0026lt;module\u0026gt;() -\u0026gt; c = add(1, 3) (Pdb) c \u0026gt; /root/autodl-tmp/test_script/test1.py(9)\u0026lt;module\u0026gt;() -\u0026gt; print(\u0026#34;===end==\u0026#34;) (Pdb) p c 4 (Pdb) p a *** NameError: name \u0026#39;a\u0026#39; is not defined (Pdb) p b *** NameError: name \u0026#39;b\u0026#39; is not defined (Pdb) s ===end=== --Return- \u0026gt; /root/autodl-tmp/test_script/test1.py(9)\u0026lt;module\u0026gt;()-\u0026gt;None -\u0026gt; print(\u0026#34;===end==\u0026#34;) (Pdb) s --Return- \u0026gt; \u0026lt;string\u0026gt;(1)\u0026lt;module\u0026gt;()-\u0026gt;None (Pdb) s \u0026gt; /root/miniconda3/lib/python3.12/bdb.py(604)run() -\u0026gt; self.guitting = True (Pdb) s The program finished and will be restarted C编译调试 gcc -g test.c -o test 将 test.c 编译为可调式、可执行文件 test(.exe) ","date":"2025-03-08T19:56:00+08:00","permalink":"https://rooobeam.github.io/p/linux%E5%91%BD%E4%BB%A4/","title":"Linux命令"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 assume cs:codesg data segment db \u0026#39;1975\u0026#39;,\u0026#39;1976\u0026#39;,\u0026#39;1977\u0026#39;,\u0026#39;1978\u0026#39;,\u0026#39;1979\u0026#39;,\u0026#39;1980\u0026#39;,\u0026#39;1981\u0026#39;,\u0026#39;1982\u0026#39;,\u0026#39;1983\u0026#39; db \u0026#39;1984\u0026#39;,\u0026#39;1985\u0026#39;,\u0026#39;1986\u0026#39;,\u0026#39;1987\u0026#39;,\u0026#39;1988\u0026#39;,\u0026#39;1989\u0026#39; dd 16,22,345,4567,6475,4567,12345,34526,65734,465436,234234 dd 123345,463654,867887,1567689 dw 4,13,76,89,99,345,567,789,890,1234,5467 dw 6789,12345,14357,16776 data ends table segment db 15 dup (\u0026#39;year summ ne ?? \u0026#39;) table ends codesg segment start: ;set sreg (segment register) mov ax,data mov ds,ax mov ax,table mov es,ax ;set reg (register) mov bx,0 ;bx add 4 bytes mov si,0 ;si add 2 bytes mov bp,0 ;bp add 16 bytes mov cx,0fh s: ;year mov ax,[bx] ;30th row mov es:[bp+0],ax mov ax,2[bx] mov es:[bp+2],ax ;sum of money mov ax,60[bx] ;low -\u0026gt; ax mov es:[bp+5],ax mov dx,62[bx] ;high -\u0026gt; dx mov es:[bp+7],dx ;n of employee mov di,120[si] mov es:[bp+10],di ;?? —— average money div di mov es:[bp+13],ax add bx,4h add bp,10h add si,2h loop s mov ax,4c00h int 21h codesg ends end start ","date":"2025-03-06T00:00:00Z","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AB%E7%AB%A0/","title":"汇编语言第八章"},{"content":"","date":"2025-03-03T00:00:00Z","permalink":"https://rooobeam.github.io/p/binary_search/","title":"Binary_search"},{"content":"☝内存单元 、\u0026quot;()\u0026quot;、 loop 和 idata [bx]\n类似[0]，[bx]表示 ds:bx上的字节单元或字单元的内存内容，bx内的4位作为偏移地址\n[0] [bx] mov ax, [0] 将地址为ds:0 的内存字单元存入ax mov ax, [bx] 将地址为ds:bx的内存单元存入ax mov al, [0] 将地址为ds:0 的内存半字单元存入al mov al, [bx] 将地址为ds:bx的内存半字单元存入al 实例 问题5.1.svg\n1 忘了要写啥了 “()\u0026quot;，机组中“(地址)”——描述某地址上的内容\n()中的元素有三种类型： 寄存器名，段寄存器名 和 五位十六进制的物理地址\n如 (ax)、(al)、(ds)、(20000H)、**((ds)*16+(bx))**注意里面的ds、bx都有括号\nax=10000H，则(ax)=(10000H)即地址10000H上的字节单元或字单元\nloop 类似“goto”\n1 2 3 4 5 6 7 8 9 10 assume cs:code code segment cx=8 s:\tax=0 loop s mov ax,4c00h int 21 code ends end ​\t首先(cx)=(cx)-1，然后判断(cx)是否等于0，如果等于0则执行下一指令，如果不等于0则跳转到s处执行。\nloop 可能情境 cx初始化8，循环8次后继续执行 cx为人为初始化，然后为0，(cx)=(cx)-1变成大数(如65535) cx设置指令在循环体内，死循环 idata\n约定符号好idata表示常量，mov ax,[idata]代表mov ax,[1]、mov ax,[2]等。\n又如 mov ds,idata 都是非法指令\n☝实验四 程序 编程，向内存0:2000:23F依次传送数据063(3FH)，程序中只能使用9条指令，9条指令中包括‘mov ax,4c00h’和‘int 21h’。\n在常见的x86汇编语言（如MASM、NASM）中，分号 ; 是标准的行注释符号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 assume cs:codesg codesg segment mov ax,020H\tmov ds,ax\t; 初始化ds，不能直接将数字传入段寄存器 mov bx,0H\t; 初始化bx因为从0 mov cx,40H\t; cx=40H即循环64次存入数据0~63 s:\t; 标记loop跳转位置 mov [bx],bl\t; 内存0:200~0:23F是40H个字节数据,要存入字节数据，bl存入cs:bx的字节单元，因为要对应bl的大小是1字节 inc bx\t; 把bx+=1 移动偏移地址 loop s\t; 减小cx, 检查判断是否跳转 mov ax,4c00H\tint 21H\t; 结束 codesg ends end ☝实验五倒二题 编写code段中的代码，将a段和b段中的数据依次相加，将结果保存到c段中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 assume cs:code a segment db 1,2,3,4,5,6,7,8 ; a 原始数据 a ends b segment db 1,2,3,4,5,6,7,8 ; b 原始数据 b ends c segment db 0,0,0,0,0,0,0,0 ; c 结果存储区 c ends code segment start: mov bx,0\t; 初始化偏移，从0开始 mov cx,8\t; 设置好循环次数 s:\tmov dx,a\tmov ds,dx\t; ds=a mov al,[bx]\t; al=a[bx] mov dx,b\tmov ds,dx\t; ds=b add al,[bx]\t; al= mov dx,c\tmov ds,dx\t; ds=c mov [bx],al\t; c[bx]=al=a[bx]+b[bx] inc bx\t;bx++ loop s\t;跳转 mov ax,4c00h\tint 21h\t; 程序退出 code ends end start\t# 指明程序的开始结尾，start处设置cs=start 创建txt，将上述代码写入，保存。 win+R进入DOS，输入\u0026quot;cd masm5\u0026quot;，再输入\u0026quot;masm\u0026quot;启动。 源文件输入 \u0026ldquo;file_name.txt\u0026rdquo; 然后四个回车 没有error后，输入\u0026quot;link\u0026quot;，obj文件输入file_name，然后回车回车回车 输入\u0026quot;debug file_name.exe\u0026quot;，进入对该exe的debug模式 输入\u0026quot;u\u0026quot;查看当前能看到的指令，看不到\u0026quot;mov ax,4c00H\u0026quot;就输入t执行一条指令，输入个三四个再输入\u0026quot;u\u0026quot;查看，总之看到结束指令的偏移地址bx 输入\u0026quot;g bx\u0026quot;，直接执行到bx处 输入\u0026quot;r\u0026quot;，查看DS，因为它是c段的首地址，因为最后一次设置DS就是用的c 实验中ds=0c25，输入“d 0c25:0\u0026quot;便能查看c处的值是不是2 4 6 8\u0026hellip;，或者输入\u0026quot;d 0c23:0\u0026quot;能对比a、b、c段的内容。 db、dw：定义数据，db即define bytes，dw即define words， ☝实验五最后一题 编写code段代码，用push指令将a段中的前8个字型数据，逆序存储到b段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 assume cs:code a segment ; 数据段a dw 1,2,3,4,5,6,7,8,0ah,0bh,0ch,0dh,0fh,0ffh a ends b segment ; 数据段b dw 0,0,0,0,0,0,0,0 b ends code segment start: mov ax, a ; 赋值ds为a段的段地址 mov ds, ax mov ax, b ; 赋值堆栈段ss为b段的段地址 mov ss, ax mov sp,10h\t;偏移到堆栈最后的字型数据后，8个字，16个字节，0c24:0~0c24:0f，ss:sp指向0c24:10，即前者加一。 mov bx, 0 ; 初始化偏移量 mov cx, 8 ; 循环次数 s: push [bx] ; 将a段第i个字型数据存入b段倒数第i个字单元内 add bx, 2h ; 按字 (word) 处理数据，故+2 loop s mov ax, 4c00h ; 退出程序 int 21h code ends end start 读代码代码后思考：各种段是如何安排的，怎么让CPU会把dode段当作代码段\n❌\ncode data stack等段名如何设置只是为了方便阅读，不能起到修改cs ds ss的作用\nassume cs:code,ds:data,ss:stack 也不能\n✅\n程序末尾end start可以设置程序入口CS:IP\n✅\nmov ax,stack\nmov ss,ax\nmov sp,20h\n设置堆栈段，stacK是你设置的作为堆栈段的段名，可以是a、c what ever you want 符合一定命名规范即可。\n✅\nmov ax,data\nmov ds,ax\n设置数据段\n每个段势必占据N行，即：\n前一个段最后一个字节单元为所在行被前一个段占有，当前段从下一行开始，每行16字节。\n前一个段最后一个字节单元 a:b，则当前段的第一个字节单元为a+[b/10h]+1:0，[ ]取整数，10h十六个字节\na:b=2:34h\ta+[34h/10h]+1:0=2+3+1:0=6:0\n","date":"2025-02-22T00:00:00Z","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250222101607_hu_56fa5440ce86c489.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0/","title":"汇编语言第五、六章"},{"content":"目录 目录结构 - - - - abs dict help min、max setattr、getattr all、any dir hex、oct next slice divmod id object sorted ascii enumerate input staticmethod bin open eval int str bool exec isinstance ord、chr sum bytes bytearray filter issubclass pow super float iter print tuple callable format、f-string len property type set frozenset list range classmethod repr zip map reversed import_module complex hasattr - abs abs(x) 返回数字的绝对值。 x 可以是整数，浮点数，复数；如果是复数，则返回它的大小。\n1 2 3 4 a=abs(-50) print(a) b=abs(3 + 4j ) print(b) dict class dict(**kwarg) 等号模式 class dict(mapping, **kwarg) zip模式 class dict(iterable, **kwarg) 二元组列表 主要是zip模式和二元元组模式\n1 2 3 4 5 6 7 8 9 x = dict() # 创建空字典{} y = dict(a=\u0026#39;a\u0026#39;, b=\u0026#39;b\u0026#39;, t=\u0026#39;t\u0026#39;) # 传入关键字，等于号模式 z = dict(zip([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;], [1, 2, 3])) # 映射函数方式，zip模式 u = dict([(\u0026#39;one\u0026#39;, 1), (\u0026#39;two\u0026#39;, 2), (\u0026#39;three\u0026#39;, 3)]) # 可迭代对象方式，二元元组代替等号模式，二元列表元素会警告 print(x, y, z, u) # 也可直接用{}、:创建字典 v = {123: \u0026#39;123\u0026#39;, 456: \u0026#39;456\u0026#39;} print(v, type(v)) help help([object])\tobject \u0026ndash; 对象；\n返回对象帮助信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 help(list) # 输出： # # Help on class list in module builtins: # class list(object) # | list(iterable=(), /) # | # | Built-in mutable sequence. # | # | If no argument is given, the constructor creates a new empty list. # | The argument must be an iterable if specified. # | # | Methods defined here: # | # ...... min、max 返回可迭代参数中的最小、最大元素。\n1 2 print (\u0026#34;min(80, 100, 1000) : \u0026#34;, min(80, 100, 1000)) print (\u0026#34;min(80, 100, 1000) : \u0026#34;, max(80, 100, 1000)) setattr、getattr (attr——attribute)\nsetattr用于设置对象的属性值，getattr用于获取对象的属性值。相比于 \u0026ldquo;.\u0026rdquo; 功能更丰富。\n当实例a有属性bar时，当使用setattr(a, \u0026lsquo;bar\u0026rsquo;, 5)时，会将实例a属性bar设置为5; 当实例a无属性bar时，会为实例a创建一个实例属性bar，赋值为5，而类属性不变。 getattr当属性不存在时避免抛出AttributeError，若设置默认值，则不会报错。例如，getattr(a, \u0026lsquo;baz\u0026rsquo;, \u0026lsquo;default\u0026rsquo;)会返回\u0026rsquo;default\u0026rsquo;，而a.baz则会引发异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A(object): bar = 1 a = A() print(getattr(a, \u0026#39;bar\u0026#39;)) # 获取属性 bar 值 setattr(a, \u0026#39;bar\u0026#39;, 5) setattr(a, \u0026#39;weight\u0026#39;, 5) # 设置属性 weight 值，不存在会为该对象创建，但类不变 print(a.bar, a.weight) b=A() try: print(getattr(b, \u0026#39;weight\u0026#39;)) except AttributeError as e: print(f\u0026#34;属性访问错误: {e}\u0026#34;)\t# 为对象创建，但类不变，b无weight属性 print(getattr(b, \u0026#39;weight\u0026#39;，-1))\t# 设置默认值，返回-1不报错 all 、any all(iterable, /)\n判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 元素除了是 0、空、None、False 外都算 True。 空元组、空列表返回值为True，这里要特别注意。 不会进入内层。 1 2 3 print(all([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;])) # 元素都不为空或0，True print(all([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;d\u0026#39;])) # 存在一个为空的元素，False print(all([[\u0026#39;\u0026#39;],[\u0026#39;\u0026#39;]]))\t# 不会进入内层，首层元素[\u0026#39;\u0026#39;]不为0、空、None、False any(iterable, /) True False 与 all相反，其他都一样。 dir dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表 带参数时——dir([object])，返回参数的属性、方法列表。 如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。 1 2 3 4 5 6 7 8 9 10 class MyClass: def __init__(self): self.public_attr = 10 self.__private_attr=20 def normal_method(self): pass obj = MyClass()\t# 实例化对象 print(dir(obj)) 输出包含 \u0026lsquo;_MyClass__private_attr\u0026rsquo;, \u0026rsquo;normal_method\u0026rsquo;, \u0026lsquo;public_attr\u0026rsquo;\n[ \u0026lsquo;_MyClass__private_attr\u0026rsquo;, \u0026lsquo;__class__\u0026rsquo;, \u0026lsquo;__delattr__\u0026rsquo;, \u0026lsquo;__dict__\u0026rsquo;, \u0026lsquo;__dir__\u0026rsquo;, \u0026lsquo;__doc__\u0026rsquo;, \u0026hellip;\u0026hellip; \u0026lsquo;normal_method\u0026rsquo;, \u0026lsquo;public_attr\u0026rsquo; ]\n实际应用场景\n快速查看对象内容 动态检查对象功能 限制暴露的接口（设置接口） 1 2 # 快速查看对象内容 print(dir()) # 查看字典的方法，如 keys, values, items 1 2 3 4 # 动态检查对象功能 obj = SomeClass() if \u0026#34;__iter__\u0026#34; in dir(my_object): print(\u0026#34;对象是可迭代的\u0026#34;) 1 2 3 4 5 6 7 8 9 10 # 限制暴露的接口（设置接口） class SecureAPI: def __init__(self): self._internal_data = 100 def __dir__(self): return [\u0026#34;public_method\u0026#34;] # 隐藏内部实现 def public_method(self): return \u0026#34;Safe data\u0026#34; 拓展：属性名以双下划线 __ 开头且不以双下划线结尾 —— 名称修饰，避免子类与父类的私有属性命名冲突，Python会自动将其转换为：_类名__属性名\t(如刚才的_MyClass__private_attr)\n1 2 3 4 5 6 7 8 class A: def __init__(self): self.__x = 1 # _A__x class B(A): def __init__(self): super().__init__() self.__x = 2 # _B__x hex 、oct hex(x)：将10进制int转为16进制且为字符串，0x为前缀。\n1 2 3 4 5 a=16 print(type(a))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; b=hex(a) print(b)\t# 0x10 print(type(b))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; hex(x)：将10进制int转为8进制且为字符串，0o为前缀。\n1 2 3 4 a=16 b=hex(a) print(b)\t# 0o20 print(type(b))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; next next()返回迭代器的的下一个项目；要和生成迭代器函数 iter() 配合使用。 1 next(iterable[, default]) 一个参数是iter()生成的迭代器实例，另一个是默认值，如果指针超出范围就输出默认。\n我理解的next()是python 内置的__next__方法，因为iter类有__next__方法，而其他的如生成器也有，自定义一个类并定义__next__方法，该类弄出的实例也可以用next()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 自定义迭代器 class MyClass: # 迭代相关 __iter__(self) # 迭代：for i in obj __next__(self) # 下一个：next(obj) # 生成器（本身就是迭代器） # \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; 不是 \u0026lt;class \u0026#39;list\u0026#39;\u0026gt;，用括号的 gen = (x for x in range(3))\tprint(next(gen)) # 0 print(next(gen)) # 1 # 文件对象（本身就是迭代器） with open(\u0026#39;data.txt\u0026#39;) as f: print(next(f)) # 直接读取第一行 print(next(f)) # 读取第二行 拓展 这样有双下划线的方法和无双下划线的有什么区别？如__getitem__(self)。 —— Python 的特殊方法（魔术方法）是由 Python 语言规范定义的。这些方法与 Python 的内置操作直接关联： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MyClass: # 基本操作 __init__(self) # 实例化：obj = MyClass() __str__(self) # 字符串转换：str(obj) __len__(self) # 长度：len(obj) # 迭代相关 __iter__(self) # 迭代：for i in obj __next__(self) # 下一个：next(obj) # 运算符 __add__(self) # 加法：obj + other __sub__(self) # 减法：obj - other # 容器操作 __getitem__(self) # 索引访问：obj[key] __setitem__(self) # 索引赋值：obj[key] = value # 使用这些特殊方法 lst = MyList() len(lst) # 调用 __len__ 3 in lst # 调用 __contains__ 判断是否contain for x in lst: ... # 调用 __iter__ # 查看所有特殊方法 # 方法1：查看内置文档 help(object) # 方法2：dir() 函数 print([m for m in dir(object) if m.startswith(\u0026#39;__\u0026#39;)]) slice slice()返回一个切片对象。\nslice(stop) slice(start, stop[, step])，(起点，终点，步长)\n直接使用 创建slice [:5] slice(None, 5) / slice(None, 5) [3::2] slice(3, None, 2) [::-1] slice(None, None, -1) 类似于a​:b:c\n1 2 3 4 5 a=list(range(10)) print(lst[2:7:2]) print(slice(2, 7, 2)) assert lst[2:7:2] == lst[slice(2, 7, 2)] 但是要保存为对象的话:\n1 2 x=2:7:2\t# ❌ 非法写法 x=slice(2, 7, 2)\t# ✅ 正确写法\t对于 lst[slice(95, 105, 2)]，为什么不用 lst[95:105:2] ? —— 定义slice的优势\n动态参数配置\n1 2 3 4 5 6 7 def dynamic_slicer(config): \u0026#34;\u0026#34;\u0026#34;根据外部配置生成切片\u0026#34;\u0026#34;\u0026#34; return data[slice(*config)] # 从配置文件读取参数 config = json.loads(\u0026#39;{\u0026#34;start\u0026#34;: 95, \u0026#34;stop\u0026#34;: 105, \u0026#34;step\u0026#34;: 2}\u0026#39;) print(dynamic_slicer(config.values())) # 动态应用切片参数 切片对象复用\n1 2 3 4 5 6 # 定义标准切片规则 DOWNSAMPLE_SLICE = slice(None, None, 4) # 每4个元素取1个 # 复用切片 video_frames = raw_frames[DOWNSAMPLE_SLICE] audio_samples = raw_audio[DOWNSAMPLE_SLICE] 多维切片基础\n1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(arr[0:2, 1:3]) # 输出 [[2 3], [5 6]] # 定义行和列的切片对象 row_slice = slice(0, 2) # 第0行到第1行（不含2） col_slice = slice(1, 3) # 第1列到第2列（不含3） print(arr[row_slice, col_slice]) # 输出 [[2 3], [5 6]] divmod divmod() 函数接受两个参数 x y（通常是两个数字），返回二元组，第一个值是 x 除以 y 的商（即整数部分），第二个值是余数。\n对于3.x，参数不能是复数， x 可以为整数/浮点数，y 也如此\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a=13 b=3 x,y=divmod(a,b) print(x,y) # 4 1 a=13.6 b=3 x,y=divmod(a,b) print(x,y)\t# 4.0 1.5999999999999996 print(x,round(y,1))\t# 4.0 1.6 a=13.6 b=3.1 x,y=divmod(a,b) print(x,y)\t# 4.0 1.1999999999999993 应用场景\n进制转换\n1 2 3 4 5 6 7 8 def int_to_base(n, base): digits = [] while n \u0026gt; 0: n, rem = divmod(n, base)\t# 除留余数法 digits.append(rem)\t# 余数先存进去，是低位 return digits[::-1]\t# 逆序 print(int_to_base(42, 16)) # [2, 10] 表示 0x2A 时间单位转换\n1 2 3 4 total_seconds = 7541 hours, rem = divmod(total_seconds, 3600) minutes, seconds = divmod(rem, 60) print(f\u0026#34;{hours}:{minutes}:{seconds}\u0026#34;) # 2:5:41 循环缓冲区处理，类似哈希表的“线性法直接mod”\n1 2 3 4 5 6 buffer_size = 1024 write_pos = 1500 # 计算实际写入位置 chunk, offset = divmod(write_pos, buffer_size) print(f\u0026#34;写入第 {chunk} 个缓冲区的 {offset} 位置\u0026#34;) id id()函数返回对象的唯一标识符，标识符是一个整数。\nCPython 中 id() 函数获取的是对象的内存地址。（python3.9——CPython3.9）\n1 2 3 4 5 a=13 b=3 print(id(a)) # 3054276471472 print(id(b))\t# 3054276471152 print(type(id(a)))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 拓展：不同的python\n需要最佳兼容性 → CPython （主，兼容性最好，标准）\n与 Java 生态整合 → Jython\n需要 .NET 互操作 → IronPython\n追求高性能 → PyPy\n嵌入式开发 → MicroPython\nobject object()：不接收任何参数，返回一个空对象 1 2 3 4 5 6 x = object() print(dir(x)) # [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, # \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, # \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, # \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;] object() 的核心价值：\n所有类的基类：提供默认行为\n轻量级对象：用于简单场景\n方法继承：提供默认的 __str__、__eq__ 等方法\nsorted sorted() 对 所有可迭代的对象 进行排序操作。\nsort 与 sorted 区别：\nsort 是 list 的方法，sorted 可对所有可迭代的对象应用。\nlist 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\nsorted(iterable, key=None, reverse=False)，三个参数，依次是 可迭代变量、选择内层元素的函数方法、升序or降序。\n1 2 3 4 ls=[(3,2),(1,4),(5,3),(2,6)] new_ls=sorted(ls,key=lambda x:x[0],reverse=True)\t# 对象为列表 ls，方法是 通过首层元素的第0个元素排序，True-\u0026gt;降序 print(ls)\t# [(3, 2), (1, 4), (5, 3), (2, 6)] print(new_ls)\t# [(5, 3), (3, 2), (2, 6), (1, 4)]\t得到 5 3 2 1 降序 sorted\u0026lt;-\u0026gt;sort reversed\u0026lt;-\u0026gt;reverse\nascii ascii(object) ，返回object的字符串，对于字符串中的非 ASCII 字符则通过 repr() 函数使用 \\x, \\u 或 \\U 编码。\n1 2 3 4 a=[[1,2,3],[3,4,5]] b=ascii(a) print(type(b)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; print(b.split(\u0026#39;,\u0026#39;)) # [\u0026#39;[[1\u0026#39;, \u0026#39; 2\u0026#39;, \u0026#39; 3]\u0026#39;, \u0026#39; [3\u0026#39;, \u0026#39; 4\u0026#39;, \u0026#39; 5]]\u0026#39;] enumerate enumerate(seq, [start=0])\n将seq的元素挨个取出和0,1,2,3\u0026hellip;.组成二元组，各个二元组组成enumerate类型，enumerate不可索引。\n1 2 3 4 5 6 7 8 seasons=[[1,2,3],[4,5,6]] print(type(enumerate(seasons)))\t# \u0026lt;class \u0026#39;enumerate\u0026#39;\u0026gt; for i, element in enumerate(seasons): print(i, element)\t# 0 [1, 2, 3]\t1 [4, 5, 6] for j in enumerate(seasons): print(type(j))\t# \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; print(j[0],j[1])\t# 0 [1, 2, 3] break （主）同时获取索引 i，和元素本身element：\n1 2 for i, element in enumerate(seasons): print(i, element) input input([prompt]) ：在命令行提示prompt，然后接收命令行输入的信息为字符串。\n1 2 a = input(\u0026#34;input:\u0026#34;) type(a) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 和strip、map结合\n1 2 3 4 5 6 7 # strip() 去掉文末空格 a=input(\u0026#39;输入：\u0026#39;).strip()\t# 输入“123 ”\t去掉文末空字符 print(len(a))\t# 3 a=input(\u0026#39;输入：\u0026#39;)\t# 输入“123 ”\t不去掉文末空字符 print(len(a))\t# 4 b=list(map(int, input(\u0026#39;输入：\u0026#39;).split())) # 输入“1 2 3”\t输出[1,2,3] 标准空白字符 字符名称 转义序列 空格 \\x20 水平制表符（Tab） \\t 换行符（LF） \\n 回车符（CR）（Mac 换行) \\r 垂直制表符 \\v 换页符 \\f staticmethod @staticmethod 用于定义静态方法的装饰器，返回函数的静态方法。\n1 2 3 4 class C(object): @staticmethod def add(a, b): return a + b 特点：\n代码中的add函数不能有“self”（实例引用）和“cls”类引用 是类命名空间中的函数，不需要实例便可调用 不能直接访问实例属性或类属性，因为无self/cls 静态方法与普通方法对比\n特征 普通方法 静态方法 第一个参数 self（实例引用） 非self非类 调用方式 实例调用 类/实例均可调用 访问权限 可访问实例属性 仅能访问传入参数 1 2 3 4 5 6 7 class MyClass: def normal_method(self): print(f\u0026#34;实例方法：{self}\u0026#34;) # 依赖实例 @staticmethod def static_method(): print(\u0026#34;静态方法\u0026#34;) # 无依赖 bin bin() 输入：一个整数 int 或者长整数 long int。返回：二进制的字符串。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a=3 print(bin(a))\t# 0b11 print(type(bin(a)))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; for i in bin(a): print(i)\t# 0\\nb\\n1\\n1\\n help(bin) # bin(number, /) # Return the binary representation of an integer. # # \u0026gt;\u0026gt;\u0026gt; bin(2796202) # \u0026#39;0b1010101010101010101010\u0026#39; open open(name[, mode[, buffering]])\n常与with联用\n1 2 3 4 5 # 例子 with open(\u0026#39;_20_data.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: # 读取数据 N\\n1 2 3 n = int(file.readline().strip()) data = list(map(int, file.read().split())) w从头写 r只读 a追加\n读写方式 是否为 二进制 是否为 可读可写 r 空 空 w b + a 共\t3*2*2=12种\n模式对照表 和 f.seek(n)\n模式 描述 文件存在 文件不存在 指针位置 r+ 读写（文件必须存在） 不清空，从指针位置“覆盖写” 报错 开头 w+ 写读（清空后读写） 必定清空，从指针位置写 创建 开头 a+ 追加读写 必定从末尾写 创建 末尾 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 创建文件 with open(\u0026#39;test_r+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;旧内容\u0026#39;) # r+ try:\t# 不存在改文件会报错 with open(\u0026#39;test_r+.txt\u0026#39;, \u0026#39;r+\u0026#39;) as f: print(f.read()) # 输出: 旧内容^ （^指针位置） f.seek(0)\t# ^旧内容\t（移动指针位置到开头） f.write(\u0026#39;新\u0026#39;) # 新^内容\t（从指针位置覆盖写入） f.seek(0)\t# ^新内容 print(f.read()) # 输出: 新内容 except FileNotFoundError: print(\u0026#34;文件不存在\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建文件 with open(\u0026#39;test_w+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;原始内容\u0026#39;) # w+ with open(\u0026#39;test_w+.txt\u0026#39;, \u0026#39;w+\u0026#39;) as f: f.write(\u0026#39;全新内容\u0026#39;) # 清空后写入 全新内容^ f.seek(0)\t# 移动指针到开头\t^全新内容 print(f.read()) # 输出: 全新内容 # 文件不存在时 import os with open(\u0026#39;new_w+.txt\u0026#39;, \u0026#39;w+\u0026#39;) as f: f.write(\u0026#39;创建内容\u0026#39;)\tf.seek(0) print(os.path.abspath(\u0026#39;new_w+.txt\u0026#39;)) # 输出: 创建的文件的绝对路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 创建文件 with open(\u0026#39;test_a+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;初始行\\n\u0026#39;) # a+ with open(\u0026#39;test_a+.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;追加行\\n\u0026#39;) # 追加行\\n^ f.seek(0) # ^初始行\\n追加行\\n print(f.read()) # 输出: 初始行\\n追加行\\n # 验证指针特性 f.seek(5) # 初始行\\n追^加行\\n f.write(\u0026#39;中间插入\u0026#39;) # 仍然追加到文件末尾！ f.seek(0) print(f.read()) # 输出: 初始行\\n追加行\\n中间插入 eval eval(表达式的字符串[, globals[, locals]])，执行一个字符串表达式，并返回表达式的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 简单表达式 result = eval(\u0026#34;2 + 3 * 4\u0026#34;) print(result) # 输出: 14 # 变量引用 x = 10 result = eval(\u0026#34;x + 5\u0026#34;) print(result) # 输出: 15 # 指定变量空间 namespace = {\u0026#39;a\u0026#39;: 2, \u0026#39;b\u0026#39;: 3}\t# 必须是字典 result = eval(\u0026#34;a + b\u0026#34;, namespace) print(result) # 输出: 5 eval() 执行代码有安全风险，可能导致代码注入漏洞，并确保仅执行可信任的字符串表达式。 设置命名空间的内置函数和类型 —— __builtins__\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 安全沙箱环境配置 safe_globals = { \u0026#39;__builtins__\u0026#39;: { \u0026#39;abs\u0026#39;: abs, \u0026#39;max\u0026#39;: max, \u0026#39;min\u0026#39;: min, \u0026#39;pow\u0026#39;: pow, \u0026#39;round\u0026#39;: round } } # 安全计算示例 result = eval(\u0026#34;pow(2, 3) + abs(-5)\u0026#34;, safe_globals) # 输出: 13 # 危险操作示例（将被阻止） try: eval(\u0026#34;open(\u0026#39;test.txt\u0026#39;)\u0026#34;, safe_globals) except NameError as e: print(f\u0026#34;安全拦截: {e}\u0026#34;) # 输出: name \u0026#39;open\u0026#39; is not defined 拓展: __builtins__\n1 2 3 4 5 6 7 # 查看内置函数列表 print(dir(__builtins__)) # 输出: [\u0026#39;ArithmeticError\u0026#39;, \u0026#39;AssertionError\u0026#39;, ...,\u0026#39; iter\u0026#39;, \u0026#39;len\u0026#39;, \u0026#39;license\u0026#39;, \u0026#39;list\u0026#39;, \u0026#39;locals\u0026#39;, \u0026#39;map\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;memoryview\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;next\u0026#39;, \u0026#39;object\u0026#39;, \u0026#39;oct\u0026#39;, \u0026#39;open\u0026#39;, ...] # 调用内置函数 print(__builtins__.len([1,2,3])) # 输出: 3 print(len([1,2,3])) # 等价 int int(x, base=10) -\u0026gt; integer，将一个数字或字符串转为一个int类型数据（10进制）, 如果没有参数返回0。 如果带参数base的话，第一个参数一定要是字符串\n1 2 3 4 5 6 7 8 9 #小数点后直接删了 print(int(3.6))\t# 3 # 如果带参数base的话，第一个参数一定要是字符串。1a为 16进制。 print(int(\u0026#39;1a\u0026#39;,16)) # 26 # int被print时都是10进制，int其他进制字符串转为10进制表示的int print(int(\u0026#39;0xaa\u0026#39;,16))\t# 16 * 10 + 1 * 10 = 70 print(int(\u0026#39;0b110\u0026#39;,2))\t# 4+2=6 int([x]) -\u0026gt; integer，[x]可以是str, bytes, or bytearray 且符合该进制（由base确定）的字面量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 with open(\u0026#39;test.txt\u0026#39;,\u0026#39;wb+\u0026#39;) as f: # 写入bytes类型内容 f.write(b\u0026#39;12\u0026#39;)\tf.seek(0) # 读取bytes byte_ls=f.readline()\tprint(byte_ls)\t# b\u0026#39;12\u0026#39; print(type(byte_ls))\t# \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; # 默认10进制转换 int_ls=int(byte_ls)\tprint(int_ls)\t# 12 print(type(int_ls))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; # 设置为8进制 int_ls=int(byte_ls, 8)\tprint(int_ls)\t# 10 str str(object=\u0026rsquo;\u0026rsquo;)，返回一个对象的字符串。\n1 print(type(str(123)))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 对比str()和ascii()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dict = {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;} # 转换一些数据结构是一样的 print(str(dict))\t# {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;} print(ascii(dict))\t# {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;} # 对于字符串数据，str不会将\u0026#39;转字符串里，ascii严格转 s = \u0026#39;rooobeam\u0026#39; print(str(s))\t# RUNOOB print(ascii(s))\t# \u0026#39;RUNOOB\u0026#39; # 对于非ASCII字符，str没事，转义为Unicode码点 ss = \u0026#39;阿道夫\u0026#39; print(str(ss))\t# 阿道夫 print(ascii(ss))\t# \u0026#39;\\u963f\\u9053\\u592b\u0026#39; 输出目标 非ASCII字符处理 字符处理 特殊字符转义 主要用途 str 人类可读的字符串 原样 无 仅转义控制字符如\\n 用户友好 ascii Python可解析str Unicode码点(如\\u4e2d) 始终用单引号包裹 转义所有非ASCII字符 调试和安全 bool bool(x) 将给定参数转换为布尔类型，如果没有参数，返回 False。\n1 2 3 print(bool(0))\t# False print(bool(1))\t# Ture print(bool(2))\t# True （bool是int的子类，然并卵。）\nReturns True when the argument x is true, False otherwise.\nexec exec(object[, globals[, locals]])，执行储存在字符串或文件中的 Python 语句，可执行更复杂的 Python 代码。\n1 2 3 4 exec(\u0026#39;\u0026#39;\u0026#39; print(\u0026#34;where you are\u0026#34;) print(\u0026#34;where is love\u0026#34;) \u0026#39;\u0026#39;\u0026#39;) globals，locals类似 eval。\n非常不安全，永远不要执行没有检验过的代码。\n可用__builtins__限制命名空间。\nisinstance isinstance(object, classinfo)——isinstance(实例a, 类A)，判断实例a 是不是 A 或 A的子类 的实例化。\n1 2 3 4 a = 2 isinstance(a,int)\t# True a是int类型 isinstance(a,str)\t# False\ta不是str类型 isinstance(a,(str,int,list)) # True 元组里有a的类型 isinstance() 与 type() 区别：\ntype() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。\n1 2 3 4 5 6 7 8 a = bool() print(type(a)==int)\t# False # 子类是父类的一种，a是子类则a是父类 print(isinstance(a,int))\t# True # 反之不成立 b = int() print(isinstance(b,bool))\t# False ord、chr ord(c)，c为字符，返回 Unicode 码点 (十进制int) for a one-character string.\n1 2 3 4 print(ord(\u0026#39;a\u0026#39;))\t# 97 print(ord(\u0026#34;a\u0026#34;))\t# 97 print(ord(\u0026#39;€\u0026#39;)) # 8364 print(type(ord(\u0026#39;a\u0026#39;)))\t# int chr(i) ，ord的反向操作 返回一个one-character string 对应输入的unicode码点(十进制int)， 0 \u0026lt;= i \u0026lt;= 0x10ffff (unicode的最大码点).\n1 2 3 print(chr(65)) # \u0026#39;A\u0026#39;（65对应\u0026#39;A\u0026#39;） print(chr(9731)) # \u0026#39;☃\u0026#39;（9731对应雪人符号） print(type(chr(9731)))\t# str sum 对iterable的元素求和\n1 2 3 print(sum([1,2,3]),sum((1,2,3)),sum({1,2,3})) # 6 6 6 print(sum(1,2,3),1)\t# 7\t组计算总和后再加 1 bytes、bytearray 初始化空bytearray、bytes bytearray() -\u0026gt; empty bytes array bytes() -\u0026gt; empty bytes object 1 print(bytearray())\t# bytearray(b\u0026#39;\u0026#39;) 初始化n个 \\x00 bytearray(int) -\u0026gt; bytes array of size given by the parameter initialized with null bytes bytes() -\u0026gt; empty bytes object 1 2 print(bytearray(2))\t# bytearray(b\u0026#39;\\x00\\x00\u0026#39;) print(bytes(2))\t# b\u0026#39;\\x00\\x00\u0026#39; 转换int的可迭代类型（[1,2,3], (1,2,3), {1,2,3}等） bytearray(iterable_of_ints) -\u0026gt; bytearray bytes(iterable_of_ints) -\u0026gt; bytes 1 2 3 # 每个int范围 in range(256) print(bytearray([1,2,3,4]))\t# bytearray(b\u0026#39;\\x01\\x02\\x03\\x04\u0026#39;) print(bytes([1,2,3,4]))\t转换字符串类型 1 2 a=bytearray(\u0026#39;八寸\u0026#39;, \u0026#39;utf-8\u0026#39;) print(a)\t# bytearray(b\u0026#39;\\xe5\\x85\\xab\\xe5\\xaf\\xb8\u0026#39;) bytes、bytearray、memoryview 和其他自定义的缓冲区对象间相互转换 bytearray(bytes_or_buffer) -\u0026gt; mutable copy of bytes_or_buffer bytes(bytes_or_buffer) -\u0026gt; immutable copy of bytes_or_buffer 1 2 3 a=b\u0026#34;abc\u0026#34;\t# bytes类型 b=bytearray(a) print(b)\t# bytearray(b\u0026#39;abc\u0026#39;)\tbytearray类型 对比。\n不同：\n是否可修改\n使用 b\u0026rsquo;\u0026rsquo; 或 bytes() 创建还是使用 bytearray() 创建\nfile.read()得出的是bytes\n相同：\n存储内容：都存储字节数据（0到255之间的整数，\\x00~\\xff）。\n二进制数据：都适合处理二进制数据，如文件、网络通信等。\n索引和切片：都支持通过索引和切片访问数据。\n1 2 3 4 5 6 7 8 9 10 11 4ea=bytearray(\u0026#39;abc\u0026#39;, \u0026#39;utf-8\u0026#39;) b=bytes(\u0026#34;ABC\u0026#34;,\u0026#39;utf-8\u0026#39;) print(a[0])\t# 97 a[0]=65 print(a[0])\t# 65 try: b[0]=97 except Exception as e: print(f\u0026#34;{e}\u0026#34;)\t# \u0026#39;bytes\u0026#39; object does not support item assignment filter filter(function or None, iterable) \u0026ndash;\u0026gt; filter object filter 函数用于过滤序列，过滤掉不符合条件的元素，返回一个filter对象。接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，函数需返回 True 或 False，最后将返回 True 的元素放到filter中。 1 2 3 4 5 6 def is_odd(n): return n % 2 == 1 a = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) b = list(a) print(b)\t# [1, 3, 5, 7, 9] 如果function那里填了None，则返回非空元素。 1 2 3 a = filter(None ,[1, 2, 0, 4, \u0026#39;\u0026#39;, 6]) b = list(a) print(b)\t# [1, 2, 4, 6] filter 对象是惰性求值的，这点类似于生成器。\n一旦迭代过 filter 对象，其内容就会被消耗，无法再次使用。\n如果需要多次访问，可转换为列表或其他可迭代对象。\n1 2 3 4 5 6 7 8 def is_odd(n): return n % 2 == 1 a = filter(is_odd, [1, 2, 3]) for i in a: print(i)\t# 1\\n3\\n b=list(a) print(b)\t# [] issubclass issubclass(class1, class2)，判断 class1 是否为 class2 的子类。 1 2 3 4 5 6 class A: pass class B(A): pass print(issubclass(B,A)) # True pow pow(base, exp, mod=None)\tpow(底数，指数，模数=None)\n两个参数时，得到 base**exp，三个参数时，得到 base**exp % mod\n对于一些类型的参数如int型参数它能算得更快。\n1 2 3 4 5 6 7 # 两个参数 print(pow(2,3))\t# 8 print(pow(2.5,2))\t# 6.25 print(pow(2,2.5))\t# 5.656854249492381 # 三个参数 print(pow(2,34,13))\t# 10 super 一句话概括：调用父类方法，改变传入实例。\nsuper(class, obj )，class——指定从哪个类开始查找父类方法，obj——传入的对象\n译为 创建一个 传入了对象obj的 可调用class的父类的方法的 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Parent: def greet(self): print(\u0026#39;Parent\u0026#39;) class Child(Parent): def greet(self): print(\u0026#39;Child\u0026#39;) def react(self): print(\u0026#39;c\u0026#39;) # 在类外部调用父类方法 c = Child() super(Child, c).greet() # Parent 在一个类里，super()=super(当前类, self)，会自动绑定当前类和实例(self)，适用于类方法中。\n译为 创建一个 传入了self的 可调用当前类的父类的方法的 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Parent(object): def __init__(self): # 定义传入的对象的属性 self.parent = \u0026#39;I\\\u0026#39;m the parent.\u0026#39;\t# 证明执行__init__方法的语句 print (\u0026#39;Parent\u0026#39;) def bar(self, message): # 证明可调用其他方法如bar print (\u0026#34;%s from Parent\u0026#34; % message) class Child(Parent): def __init__(self): # 调用parent的初始化函数，如继承父类属性 super().__init__() print (\u0026#39;Child\u0026#39;) def bar(self, message): super(Child, self).bar(message) print (\u0026#39;Child bar fuction\u0026#39;) print (self.parent) if __name__ == \u0026#39;__main__\u0026#39;: Child = Child() Child.bar(\u0026#39;HelloWorld\u0026#39;) # 输出 # Parent # Child # HelloWorld from Parent # Child bar fuction # I\u0026#39;m the parent. 可不可以理解为 super(Child,self) 首先找到 Child 的父类（Parent），然后把类 Child 的对象转换为类 Parent 的对象？ —— False\n可能会发生死循环吗？ —— True\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Parent: def __init__(self): # Parent 对象必有a属性 self.a=123\tdef react(self): self.react() class Child(Parent): def react(self): super().react() # 证明不是Parent的对象 try: print(b.a) except Exception as e: print(f\u0026#34;{e}\u0026#34;)\t# \u0026#39;super\u0026#39; object has no attribute \u0026#39;a\u0026#39; # 证明死循环 c = Child() b=super(Child, c) try: super(Child, c).react() except Exception as e: print(f\u0026#34;{e}\u0026#34;)\t# maximum recursion depth exceeded 多重继承问AI float 将一个字符串或整数转为浮点数\n1 2 3 float(123)\t# 123.0 float(\u0026#39;123\u0026#39;)\t# 123.0 float(\u0026#39;123.123\u0026#39;)\t# 123.123 iter iter() 用于获取可迭代对象的迭代器，两种传参：(iterable) 、(callable, sentinel)\niter(iterable) -\u0026gt; iterator\t传入可迭代对象，如列表、字符串，转为iter.\n（“给对象生成__iter__() 和 __next__()”）\n1 2 3 4 5 6 7 8 9 10 11 12 # 配合 next() 逐步获取元素时应用 a=iter(\u0026#34;123\u0026#34;) print(next(a))\t# 1 print(next(a))\t# 2 print(next(a))\t# 3 # iterator 惰性计算 print(list(a))\t# [] # 在for循环中隐式调用 a=iter(\u0026#34;123\u0026#34;) for i in a: print(i) iter(callable, sentinel) -\u0026gt; iterator，重复调用无参函数callable，直到其返回值等于sentinel（哨兵值）时停止 1 2 3 4 5 6 7 8 import random def get_random(): return random.randint(1, 10) it = iter(get_random, 7) for num in it: print(num) # 持续输出随机数，直到出现7时停止 拓展（__iter__）\nPython 的迭代器：实现 __iter__() 和 __next__() 方法的对象被视为迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Counter: def __init__(self, low, high): self.current = low self.high = high def __iter__(self): return self def __next__(self): if self.current \u0026gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1 # 使用 counter = Counter(1, 3) for num in counter: print(num) # 输出1, 2, 3 以后遇到了再补充了 print print(value, \u0026hellip;, sep=\u0026rsquo; \u0026lsquo;, end=\u0026rsquo;\\n\u0026rsquo;, file=sys.stdout, flush=False)\nsep间隔 默认一个空格，print完成后补充内容 默认一个换行符，输出文件 默认控制台，是否刷新缓存默认否。\n1 2 3 4 5 6 # sep print(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;, sep=\u0026#34;, \u0026#34;)\t# apple, banana, cherry # end for i in range(3): print(i, end=\u0026#34; | \u0026#34;) # 0 | 1 | 2 | （同一行） tuple tuple(iterable=(), /)，将可迭代对象转为元组类型，元组数据不可修改。 1 2 a=tuple([1,2,3]) print(a)\t# (1,2,3) 判断是否为可迭代对象 1 2 a=[1,2,3] print(\u0026#39;__iter__\u0026#39; in dir(a))\t# True callable callable（可调用对象）是指任何可以通过 () 运算符调用的对象。例如：函数、方法、类，或者实现了 call 方法的对象，是否具有__call__ 1 2 3 4 5 6 7 8 # 用 def 或 lambda 定义的函数是callable def greet(): print(\u0026#34;Hello!\u0026#34;) add = lambda x, y: x + y print(callable(greet))\t# True print(callable(add))\t# True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 类本身是 callable （类可被调用来创建实例，但对象未必） class A: pass a=A() print(callable(A))\t# True print(callable(a))\t# False # 类里定义了__call__，这样得到的对象是callable （能实现b()） class B: def __call__(self): return 0 b=B() print(callable(b))\t# True print(b())\t# 0 1 2 3 4 5 6 7 8 9 # 对象的方法是 callable class A: def react(self): print(\u0026#34;great!\u0026#34;) a = A() print(callable(a.react))\t# True\t# a.react()不是callable，方法react没有返回一个有__call__的对象 print(callable(a.react())\t# False\t拓展：类装饰器（通过 __call__ 实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class countcalls: def __init__(self, func): self.func = func self.count = 0 def __call__(self, *args, **kwargs): # 类实例成为 Callable self.count += 1 print(f\u0026#34;函数已被调用 {self.count} 次\u0026#34;) return self.func(*args, **kwargs) @CountCalls # 装饰器相当于：say_hello=countcalls(say_hello) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() # 输出：函数已被调用 1 次 → Hello! say_hello() # 输出：函数已被调用 2 次 → Hello! format、f-string 基础用法：基本替换、位置索引、传递变量值 1 2 3 4 5 6 7 8 9 10 11 12 13 # format text = \u0026#34;{} is {}\u0026#34;.format(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) print(text) # a is b text=\u0026#34;{1} is {0}\u0026#34;.format(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) print(text) # b is a c=123 text=\u0026#34;hi,{}\u0026#34;.format(c)\t# hi,123 ls=[\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;] text=\u0026#34;{0[0]} {0[1]}\u0026#34;.format(ls) print(text)\t# 1 2 1 2 3 # f-string name=八寸 text=f\u0026#34;i love {name}\u0026#34; 常用控制格式：小数位数、进制转换、小数转百分比\n特别是\tf\u0026quot;{num:2f}\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 小数位数控制 decimal=123.125 a=\u0026#34;2位：{decimal:.2f}\u0026#34; b=\u0026#34;3位：{:3f}\u0026#34;.format(decimal) # 进制 n = 255 print(\u0026#34;二进制: {:b}\u0026#34;.format(n)) # 二进制: 11111111 print(\u0026#34;十六进制: {n:x}\u0026#34;) # 十六进制: ff print(\u0026#34;十进制: {n:d}\u0026#34;) # 十进制: 255 print(\u0026#34;八进制: {:o}\u0026#34;.format(n)) # 八进制: 377 # 小数转百分比，百分号要放大括号{}里 rate = 0.8523 a = \u0026#34;完成度: {rate:.2%}\u0026#34; # 取整百分比 b= \u0026#34;完成度: {:.2}%\u0026#34;.format(rate) print(a) # 输出：完成度: 85.23% print(b) # 输出：完成度: 0.85% format或f-string下大括号用{{}}(双重大括号) 1 2 text = \u0026#34;格式占位符: {{}}\u0026#34;.format() print(text) # 格式占位符: {} 其他对齐、填充啥的要用再查就好了，太没用了 len 求各种序列的长度\n数据类型 len() 结果 字符串 字符个数（包括空格 \u0026quot; \u0026ldquo;、 \\t、\\n 等） 列表/元组 元素数量 字典 键值对数量 集合 元素数量 字节/字节数组 字节数量 自定义对象 取决于 __len__() 方法的实现 1 2 3 4 5 text = \u0026#34;Hello, 世界!\\n\u0026#34; # 包含英文、中文、符号、换行符 print(len(text)) # 11 ls=[[],[]] print(len(ls)) # 2 property property 的核心用途是将类的方法转换为“虚拟属性”，1 将方法伪装成\u0026quot;属性\u0026rdquo;， 优雅地控制\u0026quot;属性\u0026quot;。\n@property\t@ method.setter\t@method.deleter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Circle: def __init__(self, radius): self._radius = radius # 私有变量 self._pi = 3.141592653589793 @property # 通过方法返回变量，起到保护_radius作用（只读） def radius(self): return self._radius @property # 实时计算面积area def area(self): return self._pi*(self._radius**2) @radius.setter # 控制radius的修改 def radius(self, value): if value \u0026lt; 0: raise ValueError(\u0026#34;半径不能为负\u0026#34;) self._radius = value # 合法时存储 @radius.deleter # 控制radius的删除 def radius(self): print(\u0026#34;禁止删除半径！\u0026#34;) c = Circle(5) print(c.radius) # 5 print(c.area)\t# 78.53981633974483 对比 \u0026ldquo;.\u0026rdquo; 访问属性 和 使用property 场景 直接访问属性 使用 property 优势对比说明 数据校验 ❌ 无法验证 ✅ 通过 setter 控制 避免非法值赋值（如负半径） 动态计算属性值 ❌ 需手动计算 ✅ 实时计算（如 面积 = πr²） 属性值随依赖变量自动更新，无需额外调用方法 隐藏内部实现 ❌ 暴露变量名 ✅ 封装私有变量（如 _radius） 保护内部数据命名，外部仅通过属性接口访问 接口兼容性 ❌ 修改变量名会破坏外部调用 ✅ 外部仍用 obj.x，内部可自由修改 内部变量名可重构（如 _radius → _r），不影响外部调用，减少代码耦合性 type type(object) -\u0026gt; the object\u0026rsquo;s type\t返回对象的type，打印type会显示\u0026lt;\u0026hellip;.\u0026gt; 1 2 print(type(5)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; print(type(\u0026#34;hello\u0026#34;)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 是否考虑继承关系：type不承认，isinstance() 会认为子类是一种父类类型。\n即“a是A的实例，a是A的父类的实例吗”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A: pass class B(A): pass a=A() b=B() # 是子类 则 是父类 print( isinstance(B(), A) ) # True # 不承认 是子类则是父类 print( type(a) == type(b) ) # False # 是父类 不能判定 是子类 print( isinstance(A(), B) ) # False type(name, bases, dict, **kwds) -\u0026gt; a new type，了解，遇到了再补充 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 定义方法 def __init__(self, name): self.name = name def bark(self): return \u0026#34;Woof!\u0026#34; # 动态创建类 Dog = type( \u0026#39;Dog\u0026#39;, (), # 基类为空（默认继承 object） { \u0026#39;__init__\u0026#39;: __init__, \u0026#39;species\u0026#39;: \u0026#34;Canis familiaris\u0026#34;, \u0026#39;bark\u0026#39;: bark } ) set 集合 set() -\u0026gt; new empty set object 创建空集合，注意A={}创建的是空字典 1 2 3 4 a=set() b={} print(type(a),type(b))\t# \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; print(a,b)\t# set() {} set(iterable) -\u0026gt; new set object\t将可迭代数据变为集合，能起到去重效果 1 2 3 4 5 6 7 ls=[1,2,3,2] ns=set(ls) print(ns)\t# {1, 2, 3} s=\u0026#34;rooobeam\u0026#34; ns=set(s) print(ns)\t# {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;} 集合推导式 和 直接初始化 1 2 3 4 5 a={x for x in range(5)} print(a)\t# {0, 1, 2, 3, 4} b={1,2,3} print(b)\t# {1, 2, 3} 集合对象的方法 方法 作用 返回值/行为 add(element) 添加单个元素 原地修改集合，无返回值 remove(element) 删除指定元素（元素不存在时报错） 原地修改集合，元素不存在时抛 KeyError discard(element) 删除指定元素（元素不存在时不报错） 原地修改集合，无返回值 clear() 清空集合 原地清空集合，无返回值 s.update({4, 5}) → s 包含新元素 合并多个集合（原地修改） 原地修改集合，无返回值 s1.intersection_update(s2) 原地保留交集（仅保留共同元素） 原地修改集合，无返回值 s1.difference_update(s2) 原地保留差集（移除其他集合的元素） 原地修改集合，无返回值 s1.isdisjoint(s2) → True/False 判断两个集合是否无交集 返回 True/False s2 = s1.copy() → 生成独立副本 浅拷贝集合 返回新集合的浅拷贝（与原集合独立） frozenset 直译为 冻结集合\nfrozenset() -\u0026gt; empty frozenset object\n（ 空 frozenset 最重要的作用是 作为安全的不可变默认值，避免使用可变空集合如 set()时，因意外修改导致的程序逻辑错误 ）\n1 print(frozenset())\t# frozenset() frozenset(iterable) -\u0026gt; frozenset object\nBuild an immutable unordered collection of unique elements.\n创建一个 不可修改的 无序的 元素collection，元素有唯一性。\n将 可迭代数据 变成一个 冻结的集合\n1 2 3 4 5 6 7 ls=[1,2,3,2] fs=frozenset(ls) print(fs)\t# frozenset({1,2,3}) s=\u0026#34;hello\u0026#34; fs=frozenset(s) print(fs)\t# frozenset({\u0026#39;e\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;}) frozenset({A, B})类似一个“组合值”，可以作为字典的键或集合的元素（可哈希性） 1 2 3 4 5 6 7 fs = frozenset({1, 2}) dict = {fs: \u0026#34;1, 2\u0026#34;} print(dict[fs])\t# 1, 2 fs_set={fs,1} print(fs_set)\t# {1, frozenset({1, 2})} 支持集合操作 作用 方法 返回并集 fs1.union(fs2) → 同 `fs1 返回交集 fs1.intersection(fs2) → 同 fs1 \u0026amp; fs2 返回差集（A - B） fs1.difference(fs2) → 同 fs1 - fs2 判断是否为子集 fs1.issubset(fs2) → False 返回副本（与原对象相同） fs2=fs.copy() → 新 frozenset list list(iterable=(), /), 函数/操作 作用 示例 定义列表 创建列表 my_list = [1, \u0026quot;a\u0026quot;, True] 索引 访问单个元素（支持正负索引） my_list[0]，my_list[-1] 切片 截取子列表 my_list[1:3] 直接赋值 修改单个元素 my_list[0] = 100 切片赋值 修改或替换子列表 my_list[1:2] = [200, 300] append(x) 在末尾添加单个元素 list = [1,2]; list.append(3) extend(iterable) 合并可迭代对象到末尾 list = [1,2]; list.extend([3,4]) → [1,2,3,4] del list[0:2] 删除元素 list = [1,2,3]; del list[1] → [1,3] 列表推导式 生成列表 y=[x if x\u0026gt;1 else -1 for x in [1,2,3] ] sort() 原地排序 list = [3,1,2]; list.sort() reverse() 原地反转列表顺序 list = [1,2,3]; list.reverse() copy() 创建浅拷贝列表 new_list = list.copy() count(x) 统计元素 x 的出现次数 list = [1,2,2,3]; list.count(2) -\u0026gt; 2 index(x) 返回 x 第一次出现的索引 list = [1,2,2,3]; list.index(2) -\u0026gt; 1 浅拷贝 复制外层对象（嵌套共享引用） a = [[1,2],3]; b = a.copy() len(list) 返回列表长度 len([1,2,3]) max(list) 返回最大值 max([1,3,2]) min(list) 返回最小值 min([1,3,2]) sum(list) 对数值列表求和 sum([1,2,3]) any(list) 检查是否存在为 True 的元素 any([0, False, 1]) all(list) 检查是否所有元素为 True all([1, True, 0]) enumerate(list) 返回索引-值对的迭代器 list(enumerate([\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;])) 列表推导式 enumerate 同时获取 索引和元素 1 2 3 ls=[\u0026#34;i\u0026#34;,\u0026#34;love\u0026#34;,\u0026#34;you\u0026#34;] for i,elem in enumerate(ls): print(i,elem,end=\u0026#39; \u0026#39;)\t# 0 is i 1 is love 2 is you range range(end) -\u0026gt; [0, end,1) “从0开始，到end之前，包括0不包括end，步长为1” 1 2 for number in range(6): print(number,end=\u0026#39; \u0026#39;)\t# 0 1 2 3 4 5 range(start, end, step) -\u0026gt; [start, end, step) “从start开始，到end之前，包括start不包括end，步长为step” 1 2 for number in range(1, 6, 2): print(number,end=\u0026#39; \u0026#39;)\t# 1 3 5 range(start, end, -1) -\u0026gt; [start, end, -1) 从大到小的range，step为负值，start必须\u0026gt;=end 1 2 for number in range(6, 1, -2): print(number,end=\u0026#39; \u0026#39;)\t# 6 4 2 classmethod classmethod是一种装饰器，用于**@classmethod定义类方法**。 方法类型 装饰器 首个参数 访问权限 典型场景 实例方法 无 self 实例属性、类属性 操作实例数据 类方法 @classmethod cls 类属性、其他类方法 工厂方法、操作类状态 静态方法 @staticmethod 无 无法访问类属性、实例属性 工具函数，与类逻辑相关但不依赖数据 用于需要访问或修改类状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A(object): bar = 1 def func1(self): print (\u0026#39;hi\u0026#39;) @classmethod def func2(cls): print (\u0026#39;func2\u0026#39;) # 访问类属性 print (cls.bar) # 调用 类中的普通方法 cls().func1() A.func2() # 不需要实例化 实现工厂模式 —— 类方法创建对象，比如，根据文件扩展名（如.json、.xml、.csv）创建相应的解析器对象，封装了 所支持的格式 的 类属性、获取特定格式对象 的 类方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Parser: _supported_formats = [\u0026#34;.json\u0026#34;, \u0026#34;.xml\u0026#34;, \u0026#34;.csv\u0026#34;] @classmethod def create_parser(cls, file_path): # 访问类属性获取支持格式 for fmt in cls._supported_formats: if file_path.endswith(fmt): return cls._get_parser_by_format(fmt) raise ValueError(\u0026#34;Unsupported format\u0026#34;) @classmethod def _get_parser_by_format(cls, fmt): # 调用其他类方法 if fmt == \u0026#34;.json\u0026#34;: return JsonParser() elif fmt == \u0026#34;.xml\u0026#34;: return XmlParser() elif fmt == \u0026#34;.csv\u0026#34;: return CsvParser() # 调用 parser = Parser.create_parser(\u0026#34;data.json\u0026#34;) repr repr(obj, /)\t返回对象的规范字符串，用于明确描述对象状态。\n始终为自定义类定义__repr__，避免默认的\u0026lt;ClassName object at 0x...\u0026gt;输出。优先使用\nf-string生成返回值。\nprint()时 或 交互式环境中输入对象名时（如\u0026gt;\u0026gt;\u0026gt; obj） 调用obj的__repr__输出相关信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A: def __init__(self, x): self.x = x def __repr__(self): return f\u0026#34;x={self.x}\u0026#34; # 明确且可还原的表示 a = A(3) print(a) # x=3 print(repr(a)) # x=3 class B: def __init__(self, x): self.x = x b=B(7) print(b)\t# \u0026lt;__main__.B object at 0x000001893F4A6E80\u0026gt; zip zip(*iterables) ，*iterables表名可有多个可迭代对象，返回一个元素为元组的 zip 对象，以最短的可迭代对象为终点。 1 2 3 4 5 6 7 8 9 10 a = [1,2,3] b = [4,5,6] c = [4,5,6,7,8] zip_ab = zip(a,b) print(list(zip_ab)) # [(1, 4), (2, 5), (3, 6)] # 元素个数与最短的列表一致 zip_ac = zip(a,c) print(list(zip_ac)) # [(1, 4), (2, 5), (3, 6)] 其他： N个iterable的则N元组， 惰性计算类似生成器、iter()，过一遍就没了 zip(*) 解压 1 2 3 4 5 6 7 8 9 10 11 12 13 14 a=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] b=[1,2,3,4] c=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;] # a,b,c -\u0026gt; 三元组 zip_abc=zip(a,b,c) print(list(zip_abc))\t# [(\u0026#39;a\u0026#39;, 1, \u0026#39;A\u0026#39;), (\u0026#39;b\u0026#39;, 2, \u0026#39;B\u0026#39;), (\u0026#39;c\u0026#39;, 3, \u0026#39;C\u0026#39;)] # 过一遍就没了，要重生成 print(list(zip_abc))\t# [] # 与 zip 相反，zip(*) 可理解为解压， aa, bb, cc = zip(*zip_abc) print(aa,bb,cc)\t# (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) (1, 2, 3) (\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) 把各个迭代对象压缩在一起，可以一起遍历，且惰性计算。（占空间小） map map(func, *iterables)\t创建一个迭代器(map)，存有各可迭代对象的参数依次执行函数计算的结果，当最短的可迭代对象耗尽时终止。 数据值处理 1 2 3 4 5 a=[1,2,3,4] b=[10,20,30,40] map_ab=map(lambda x,y:x+y,a,b) for i in map_ab: print(i,end=\u0026#39; \u0026#39;)\t# 11 22 33 44 数据类型处理，用上各种内置函数如int list str，但不括号 1 2 3 4 5 6 7 # 输入1 2，输出1 2，输入小数也会转为int类型 a,b = map(int, input().split()) print(a,b) # 字母大写 m = map(str.upper, [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;]) print(list(m)) # [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] reversed reversed(sequence, /) Return a reverse iterator over the values of the given sequence. 迭代器类型，占用空间没那么大，惰性计算，过一遍就没了\u0026hellip; 注意要加\u0026rsquo;d\u0026rsquo; reversed 1 2 3 a=[1,2,3] b=reversed(a) print([e for e in b])\t# [3,2,1] -更常用的方式：[::-1]。但得是可切片型数据，即要有__getitem__方法\n1 2 3 ls = [1,2,3] new_ls=ls[::-1] print(new_ls)\t# [3,2,1] import_module 动态导入模块，尤其是在需要根据运行时条件（如配置文件、用户输入、插件系统等）决定加载哪些模块。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from importlib import import_module # 根据配置(字典)选择模块 config = {\u0026#34;DATABASE\u0026#34;: \u0026#34;mysql\u0026#34;} # 可能的值: \u0026#34;mysql\u0026#34;, \u0026#34;postgresql\u0026#34;, \u0026#34;sqlite\u0026#34; db_module = import_module(f\u0026#34;database.{config[\u0026#39;DATABASE\u0026#39;]}\u0026#34;) # main.py 中动态导入 utils # 目录结构 # mypackage / # |_ __init__.py # |_ utils.py # |_ main.py utils = import_module(\u0026#34;.utils\u0026#34;, package=\u0026#34;mypackage\u0026#34;) # package 参数指定了相对导入的基准包（即 . 的起点），package=\u0026#34;mypackage\u0026#34;， # 则 .utils 表示 mypackage.utils # 加载 plugins 目录下的所有插件 plugin_names = [\u0026#34;plugin1\u0026#34;, \u0026#34;plugin2\u0026#34;] # 可动态扫描目录获取 plugins = [] for name in plugin_names: plugin = import_module(f\u0026#34;plugins.{name}\u0026#34;) complex complex([real[, imag]])，返回复数 1 2 3 4 5 6 7 8 9 10 11 12 a=complex(1, 2)\tprint(a)\t# (1 + 2j) a=complex(1) print(a) # (1 + 0j) a=complex(\u0026#34;1\u0026#34;) print(a)\t# (1 + 0j) # 注意：这个地方在\u0026#34;+\u0026#34;号两边不能有空格，也就是不能写成\u0026#34;1 + 2j\u0026#34;，应该是\u0026#34;1+2j\u0026#34;，否则会报错 a=complex(\u0026#34;1+2j\u0026#34;) print(a)\t# (1 + 2j) hasattr hasattr(obj, name, /) Return whether the object has an attribute with the given name.\nhasattr(检查对象, 名字)\n检查对象（类实例、类、模块等）是否有 指定的 属性/方法，返回True/False\n属性/方法：字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 检查属性是否存在 class A: def __init__(self, name): self.name = name a = A(\u0026#34;Alice\u0026#34;) print(hasattr(a, \u0026#34;name\u0026#34;)) # 输出: True print(hasattr(a, \u0026#34;age\u0026#34;)) # 输出: False # 检查方法是否存在 class B: def add(self, a, b): return a + b print(hasattr(B, \u0026#34;add\u0026#34;)) # 输出: True print(hasattr(B, \u0026#34;multiply\u0026#34;)) # 输出: False 复习getattr、setattr rooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\nrooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\nrooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\n10000词！\n","date":"2025-02-21T00:00:00Z","image":"https://rooobeam.github.io/p/python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/rz0sefu53fe_hu_359b55b65c1f5167.webp","permalink":"https://rooobeam.github.io/p/python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","title":"Python3内置函数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # deepseek-r1生成后删减得来 import sys import platform import subprocess from importlib.metadata import distributions def get_environment_info(): env_info = { # 系统信息 \u0026#34;操作系统\u0026#34;: f\u0026#34;{platform.system()} {platform.release()} {platform.version()}\u0026#34;, \u0026#34;系统架构\u0026#34;: platform.architecture()[0], \u0026#34;主机名\u0026#34;: platform.node(), # Python环境 \u0026#34;Python版本\u0026#34;: sys.version.replace(\u0026#39;\\n\u0026#39;, \u0026#39; \u0026#39;), \u0026#34;虚拟环境\u0026#34;: \u0026#34;是\u0026#34; if hasattr(sys, \u0026#39;real_prefix\u0026#39;) or sys.prefix != sys.base_prefix else \u0026#34;否\u0026#34;, # 包管理信息 \u0026#34;已安装包\u0026#34;: [f\u0026#34;{dist.metadata[\u0026#39;Name\u0026#39;]}=={dist.version}\u0026#34; for dist in distributions()], } # 获取conda信息（如果可用） try: result = subprocess.run([\u0026#39;conda\u0026#39;, \u0026#39;list\u0026#39;], capture_output=True, text=True, check=True) env_info[\u0026#34;Conda包列表\u0026#34;] = result.stdout.splitlines() except: env_info[\u0026#34;Conda包列表\u0026#34;] = \u0026#39;conda list fail\u0026#39; pass return env_info if __name__ == \u0026#34;__main__\u0026#34;: info = get_environment_info() # 打印摘要信息 print(\u0026#34;=\u0026#34; * 50 + \u0026#34;\\n环境配置摘要:\\n\u0026#34; + \u0026#34;=\u0026#34; * 50) print(f\u0026#34;操作系统: {info[\u0026#39;操作系统\u0026#39;]}\u0026#34;) print(f\u0026#34;Python版本: {info[\u0026#39;Python版本\u0026#39;].split(\u0026#39; [\u0026#39;)[0]}\u0026#34;) print(f\u0026#34;虚拟环境: {info[\u0026#39;虚拟环境\u0026#39;]}\u0026#34;) print(f\u0026#34;已安装包数量: {len(info[\u0026#39;已安装包\u0026#39;])}\u0026#34;) # 保存完整信息到文件 with open(\u0026#34;environment_report.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: for key, value in info.items(): f.write(f\u0026#34;\\n=== {key} ===\\n\u0026#34;) if isinstance(value, list): f.write(\u0026#39;\\n\u0026#39;.join(value)) elif isinstance(value, dict): for k, v in value.items(): f.write(f\u0026#34;{k}: {v}\\n\u0026#34;) else: f.write(str(value)) print(\u0026#34;\\n完整环境报告已保存到 environment_report.txt\u0026#34;) ","date":"2025-02-21T00:00:00Z","image":"https://rooobeam.github.io/p/%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84txt/preview%281%29_hu_f70373dca115e4ca.jpg","permalink":"https://rooobeam.github.io/p/%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84txt/","title":"生成当前环境配置的txt"},{"content":"寄存器（内存访问） ✅\n(⊙﹏⊙) ","date":"2025-02-19T21:22:11+08:00","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%95%96%E5%85%89_hu_ca55c6edaf6ec37c.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/","title":"汇编语言第三章"},{"content":"第一个程序 ✅\n源程序写出到执行简要过程，后文有实例： 编写源程序 —— 写一个文本文件 —— 使用edit、笔记本等。 编译连接 —— 用汇编语言编译程序对文本文件编译产生目标文件；再用连接程序对目标文件进行连接，生成可执行文件。 在操作系统中执行文件。 ✅\n源程序简单结构 1 2 3 4 5 6 7 8 9 10 11 12 13 assume 寄存器:某segment段, 寄存器:某segment段, 寄存器:某segment段 XXX segment : : : XXX ends YYY segment : mov ax,4c00H int 21H YYY ends end 伪指令：提供给编译器的，编译器根据伪指令进行编译工作。上面代码中assume，XXX segment……XXX ends 和 end。 标号，如segment段的名称 上面代码中的XXX、YYY，一个标号指代一个地址。 程序返回：将CPU的控制权还给 使他得以运行的程序（shell)。代码中的 mov ax,4C00H \\n int 21H 。 ✅\n实例\n编写源程序 svg\n​\t桌面右键新建txt命名123，记事本里写好源程序。\n编译 svg\nwin+R 输入command打开命令提示符，输入“cd masm”（masm.exe所在目录），输入“masm”启动masm.exe。 提示我们输入源文件名，txt文件放在了c:\\asm，且不是asm文件，输入c:\\asm\\123.txt。（注意此处的斜杠是和\\n\\t一样的） 询问生成obj文件名，我们选择默认，回车即可。 提示输入列表文件名，该文件为编译为目标文件的中间结果，我们不生成，回车即可。 提示输入交叉引用文件名，也是中间结果，不生成，回车即可。 无错误则masm.exe所在目录下生成123.obj 连接 svg\n进入DOS方式(win+R 输command)，进入c:/masm (Overlay Linker3.60，link.exe所在目录),输入link启动link.exe。 提示输入目标文件名，[.OBJ]提示默认扩展名为obj，正合我意，输入123即可。 提示生成的exe文件名，默认名就行，回车即可。 提示输入映像文件名，提示输入库文件名，我们都回车即可。 无error则当前目录下生成123.exe。 执行，命令行输入文件名就行了，masm.exe 或 masm 123.exe 或 123 。\ndebug跟踪程序的运行过程：debug 可以将程序载入内存，设置CS:IP指向程序的入口，但debug不放弃cpu的控制权\n具体方法：debug 123.exe svg 运用第二章的debug的使用方法 R命令查看、改变寄存器内容 D查看内存中内容 E改写内存内容 U将内存中机器指令(01\u0026hellip;)翻译以为汇编命令(mov\u0026hellip;) T执行一条机器指令 A以汇编指令格式往内存写入机器指令 P正常结束程序。 实操如下图： svg ✅\nexe执行过程与shell DOS中，123.exe若要运行，要有一个正在运行的程序p2将其载入内存，123.exe运行完后即将cpu控制权交还程序p2。 p2即command.com，被成为命令解释器，即DOS系统的shell。输入cd、dir、type等都由command执行。 提示符\u0026quot;c:\\masm“后输入123.exe，此时command.com运行。 输入123.3exe后，command根据文件名找到该可执行文件，将程序载入内存，设置CS:IP指向程序入口，随后执行程序。 执行完回到command。 dos中.exe的加载过程（上面第二步——载入内存） 找到SA:0000空闲内存区——\u0026gt;前256即偏移地址0-255创程序段前缀(PSP)，DOS要用它和.exe通信——\u0026gt;后面装入程序，即从SA+10H:0000——\u0026gt;CS:IP=SA+10H:0000 加载.svg ✅\n习题 习题.svg ","date":"2025-02-19T00:00:00Z","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%B8%89%E9%BE%99_hu_87bde1cf9b7bc30f.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/","title":"汇编语言第四章"},{"content":"寄存器 ✅\n8086cpu有14个寄存器：AX BX CX DS SI DI SP BP IP CS SS DS ES PSW。\n8086cpu寄存器都是16位的。\nABCD-X通常用来存放一般性数据，被成为通用寄存器。\n寄存器?X可被分为?H和?L，如AX分为AH AL，即分为AHigh ALow，前者是高八位，后者是第八位。\n所谓高位和数字的高位联想，都是左边是高位。\n✅\n几条汇编指令：mov add，用法一样。add ax,18H; add ax,8H。\n数字默认16进制。\nmov ax,bx; mov ax,7。\n两个操作对象位数一致，第一个位置要是变量，如mov ah,bl; mov bh, AA。\n✅\n物理地址即内存在统一的逻辑存储器中的地址。\n内存地址空间:cpu将系统中各类存储器看作一个逻辑存储器。\n物理地址=段地址*16+偏移地址，通常写作 段地址:偏移地址，如cpu指令读取开始地址CS:IP。\n由于十六进制，故其实即 “段地址0+偏移地址”，由一个地址加法器合成。\n段的概念：段地址固定，偏移地址连续的内存空间。故其最大范围0000~FFFF。实践发现，0-1会自动变成FFFF，FFFF+1变成0000。\n✅\n8086有四个段寄存器：CS DS SS ES。\nCS和IP：CS叫代码 段寄存器，IP 叫指令指针寄存器，CS存段地址IP存偏移量。\ncpu将从CS:IP单元开始读取一条指令并执行。\n取指执行过程：从CS:IP读取指令，该指令进入指令缓冲器；IP=IP+该指令长度，从而指向下一指令首单元；执行指令；从CS:IP读取指令\u0026hellip;\u0026hellip;.\n修改CS IP命令——jmp jmp 段地址:偏移地址\t段地址修改CS 偏移地址修改IP jmp “四位数” 仅修改IP jmp 某合法寄存器\t仅修改IP，IP=某合法寄存器的值\n","date":"2025-02-12T22:10:35+08:00","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/vglcjtiwyh9bnm0o_hu_b0d85bfc829806f3.webp","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"汇编语言第二章"},{"content":"正文 设备：win2000VM虚拟机，win11宿主机\nwin11上：如何搭建FTP：https://zhuanlan.zhihu.com/p/36070173\nwin2000上：\n调为NAT模式； 我的电脑-\u0026gt;网上邻居-\u0026gt;地址栏输入ftp://宿主机wlan地址 搞定。\n？？？\n","date":"2025-02-05T13:08:00+08:00","permalink":"https://rooobeam.github.io/p/ftp%E5%AE%9E%E8%B7%B5/","title":"Ftp实践"},{"content":"","date":"2025-01-18T10:28:00+08:00","permalink":"https://rooobeam.github.io/p/newblog/","title":"Newblog"},{"content":"","date":"2025-01-18T09:50:26+08:00","permalink":"https://rooobeam.github.io/p/newtest/","title":"Newtest"},{"content":"hello hi fine 测试简体中文能否显示\n","date":"2025-01-17T19:46:01+08:00","permalink":"https://rooobeam.github.io/p/firstblog/","title":"FirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://rooobeam.github.io/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"https://rooobeam.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://rooobeam.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://rooobeam.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://rooobeam.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://rooobeam.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://rooobeam.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://rooobeam.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://rooobeam.github.io/p/emoji-support/","title":"Emoji Support"}]