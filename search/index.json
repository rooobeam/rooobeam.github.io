[{"content":":one: [bx] 内存单元 loop \u0026ldquo;()\u0026rdquo; idata\n[bx]\n类似[0]，[bx]表示 ds:bx上的1/2字节的内存内容，bx内的4位作为偏移地址\nmov ax, [0] 将地址为ds:0 的内存字单元存入ax mov al, [0] 将地址为ds:0 的内存半字单元存入al mov ax, [bx] 将地址为ds:bx的内存单元存入ax mov al, [bx] 将地址为ds:bx的内存半字单元存入al\n实例 bx.svg\n1 2 # mov ax,2000H ☝\n☝\n","date":"2025-02-22T00:00:00Z","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E7%AB%A0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250222101607_hu_56fa5440ce86c489.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E7%AB%A0/","title":"汇编语言第五章"},{"content":"abs abs(x) 返回数字的绝对值。 x 可以是整数，浮点数，复数；如果是复数，则返回它的大小。\n1 2 3 4 a=abs(-50) print(a) b=abs(3 + 4j ) print(b) dict class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg)\n主要是zip模式和二元元组模式\n1 2 3 4 5 6 7 8 9 x = dict() # 创建空字典{} y = dict(a=\u0026#39;a\u0026#39;, b=\u0026#39;b\u0026#39;, t=\u0026#39;t\u0026#39;) # 传入关键字，等于号模式 z = dict(zip([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;], [1, 2, 3])) # 映射函数方式，zip模式 u = dict([(\u0026#39;one\u0026#39;, 1), (\u0026#39;two\u0026#39;, 2), (\u0026#39;three\u0026#39;, 3)]) # 可迭代对象方式，二元元组代替等号模式，二元列表元素会警告 print(x, y, z, u) # 也可直接用{}、:创建字典 v = {123: \u0026#39;123\u0026#39;, 456: \u0026#39;456\u0026#39;} print(v, type(v)) help help([object])\tobject \u0026ndash; 对象；\n返回对象帮助信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 help(list) # 输出： # # Help on class list in module builtins: # class list(object) # | list(iterable=(), /) # | # | Built-in mutable sequence. # | # | If no argument is given, the constructor creates a new empty list. # | The argument must be an iterable if specified. # | # | Methods defined here: # | # ...... min、max 返回可迭代参数中的最小、最大元素。\n1 2 print (\u0026#34;min(80, 100, 1000) : \u0026#34;, min(80, 100, 1000)) print (\u0026#34;min(80, 100, 1000) : \u0026#34;, max(80, 100, 1000)) setattr、getattr (attr——attribute)\nsetattr用于设置对象的属性值，getattr用于获取对象的属性值。相比于 \u0026ldquo;.\u0026rdquo; 功能更丰富。\n当实例a有属性bar时，当使用setattr(a, \u0026lsquo;bar\u0026rsquo;, 5)时，会将实例a属性bar设置为5; 当实例a无属性bar时，会为实例a创建一个实例属性bar，赋值为5，而类属性不变。 getattr当属性不存在时避免抛出AttributeError，若设置默认值，则不会报错。例如，getattr(a, \u0026lsquo;baz\u0026rsquo;, \u0026lsquo;default\u0026rsquo;)会返回\u0026rsquo;default\u0026rsquo;，而a.baz则会引发异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A(object): bar = 1 a = A() print(getattr(a, \u0026#39;bar\u0026#39;)) # 获取属性 bar 值 setattr(a, \u0026#39;bar\u0026#39;, 5) setattr(a, \u0026#39;weight\u0026#39;, 5) # 设置属性 weight 值，不存在会为该对象创建，但类不变 print(a.bar, a.weight) b=A() try: print(getattr(b, \u0026#39;weight\u0026#39;)) except AttributeError as e: print(f\u0026#34;属性访问错误: {e}\u0026#34;)\t# 为对象创建，但类不变，b无weight属性 print(getattr(b, \u0026#39;weight\u0026#39;，-1))\t# 设置默认值，返回-1不报错 all / any all(iterable, /)\n判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 元素除了是 0、空、None、False 外都算 True。 空元组、空列表返回值为True，这里要特别注意。 不会进入内层。 1 2 3 print(all([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;])) # 元素都不为空或0，True print(all([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;d\u0026#39;])) # 存在一个为空的元素，False print(all([[\u0026#39;\u0026#39;],[\u0026#39;\u0026#39;]]))\t# 不会进入内层，首层元素[\u0026#39;\u0026#39;]不为0、空、None、False any(iterable, /) True False 与 all相反，其他都一样。 dir dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表 带参数时——dir([object])，返回参数的属性、方法列表。 如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。 1 2 3 4 5 6 7 8 9 10 class MyClass: def __init__(self): self.public_attr = 10 self.__private_attr=20 def normal_method(self): pass obj = MyClass()\t# 实例化对象 print(dir(obj)) 输出包含 \u0026lsquo;_MyClass__private_attr\u0026rsquo;, \u0026rsquo;normal_method\u0026rsquo;, \u0026lsquo;public_attr\u0026rsquo;\n[ \u0026lsquo;_MyClass__private_attr\u0026rsquo;, \u0026lsquo;__class__\u0026rsquo;, \u0026lsquo;__delattr__\u0026rsquo;, \u0026lsquo;__dict__\u0026rsquo;, \u0026lsquo;__dir__\u0026rsquo;, \u0026lsquo;__doc__\u0026rsquo;, \u0026hellip;\u0026hellip; \u0026lsquo;normal_method\u0026rsquo;, \u0026lsquo;public_attr\u0026rsquo; ]\n实际应用场景\n调试时快速查看对象内容\n1 print(dir()) # 查看字典的方法，如 keys, values, items 动态检查对象功能\n1 2 3 4 # 动态检查对象能力 obj = SomeClass() if \u0026#34;__iter__\u0026#34; in dir(my_object): print(\u0026#34;对象是可迭代的\u0026#34;) 限制暴露的接口（设置接口）\n1 2 3 4 5 6 7 8 9 class SecureAPI: def __init__(self): self._internal_data = 100 def __dir__(self): return [\u0026#34;public_method\u0026#34;] # 隐藏内部实现 def public_method(self): return \u0026#34;Safe data\u0026#34; 拓展：属性名以双下划线 __ 开头且不以双下划线结尾 —— 名称修饰，避免子类与父类的私有属性命名冲突，Python会自动将其转换为：_类名__属性名\t(如刚才的_MyClass__private_attr)\n1 2 3 4 5 6 7 8 class A: def __init__(self): self.__x = 1 # _A__x class B(A): def __init__(self): super().__init__() self.__x = 2 # _B__x hex / oct hex(x)：将int转为16进制且为字符串，0x为前缀。\n1 2 3 4 5 a=16 print(type(a))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; b=hex(a) print(b)\t# 0x10 print(type(b))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; hex(x)：将int转为8进制且为字符串，0o为前缀。\n1 2 3 4 a=16 b=hex(a) print(b)\t# 0o20 print(type(b))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; next next()返回迭代器的的下一个项目；要和生成迭代器函数 iter() 配合使用。\n1 next(iterable[, default]) 一个参数是iter()生成的迭代器实例，另一个是默认值，如果指针超出范围就输出默认。\n我理解的next()是python 内置的__next__方法，因为iter类有__next__方法，而其他的如生成器也有，自定义一个类并定义__next__方法，该类弄出的实例也可以用next()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 自定义迭代器 class MyClass: # 基本操作 __init__(self) # 实例化：obj = MyClass() __len__(self) # 长度：len(obj) # 迭代相关 __iter__(self) # 迭代：for i in obj __next__(self) # 下一个：next(obj) # 容器操作 __getitem__(self) # 索引访问：obj[key] __setitem__(self) # 索引赋值：obj[key] = value # 生成器（本身就是迭代器） gen = (x for x in range(3))\t# \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; 不是 \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; print(next(gen)) # 0 print(next(gen)) # 1 # 文件对象（本身就是迭代器） with open(\u0026#39;data.txt\u0026#39;) as f: print(next(f)) # 直接读取第一行 print(next(f)) # 读取第二行 拓展 这样有双下划线的方法和无双下划线的有什么区别？如__getitem__(self)。 —— Python 的特殊方法（魔术方法）是由 Python 语言规范定义的。这些方法与 Python 的内置操作直接关联：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MyClass: # 基本操作 __init__(self) # 实例化：obj = MyClass() __str__(self) # 字符串转换：str(obj) __len__(self) # 长度：len(obj) # 迭代相关 __iter__(self) # 迭代：for i in obj __next__(self) # 下一个：next(obj) # 运算符 __add__(self) # 加法：obj + other __sub__(self) # 减法：obj - other # 容器操作 __getitem__(self) # 索引访问：obj[key] __setitem__(self) # 索引赋值：obj[key] = value # 使用这些特殊方法 lst = MyList() len(lst) # 调用 __len__ 3 in lst # 调用 __contains__ 判断是否contain for x in lst: ... # 调用 __iter__ # 查看所有特殊方法 # 方法1：查看内置文档 help(object) # 方法2：dir() 函数 print([m for m in dir(object) if m.startswith(\u0026#39;__\u0026#39;)]) slice slice()返回一个切片对象。\nslice(stop) slice(start, stop[, step])，(起点，终点，步长)\n直接使用 创建slice [:5] slice(None, 5) / slice(None, 5) [3::2] slice(3, None, 2) [::-1] slice(None, None, -1) 类似于a​:b:c\n1 2 3 4 a=list(range(10)) print(lst[2:7:2]) print(slice(2, 7, 2)) assert lst[2:7:2] == lst[slice(2, 7, 2)] 但是要保存为对象的话:\n❌ 非法写法\tx=2:7:2 ✅ 正确写法\tx=slice(2, 7, 2)\n对于 lst[slice(95, 105, 2)]，为什么不用 lst[95:105:2] ? —— 定义slice的优势\n动态参数配置\n1 2 3 4 5 6 7 def dynamic_slicer(config): \u0026#34;\u0026#34;\u0026#34;根据外部配置生成切片\u0026#34;\u0026#34;\u0026#34; return data[slice(*config)] # 从配置文件读取参数 config = json.loads(\u0026#39;{\u0026#34;start\u0026#34;: 95, \u0026#34;stop\u0026#34;: 105, \u0026#34;step\u0026#34;: 2}\u0026#39;) print(dynamic_slicer(config.values())) # 动态应用切片参数 切片对象复用\n1 2 3 4 5 6 # 定义标准切片规则 DOWNSAMPLE_SLICE = slice(None, None, 4) # 每4个元素取1个 # 复用切片 video_frames = raw_frames[DOWNSAMPLE_SLICE] audio_samples = raw_audio[DOWNSAMPLE_SLICE] 多维切片基础\n1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(arr[0:2, 1:3]) # 输出 [[2 3], [5 6]] # 定义行和列的切片对象 row_slice = slice(0, 2) # 第0行到第1行（不含2） col_slice = slice(1, 3) # 第1列到第2列（不含3） print(arr[row_slice, col_slice]) # 输出 [[2 3], [5 6]] divmod divmod() 函数接受两个参数 x y（通常是两个数字），返回二元组，第一个值是 x 除以 y 的商（即整数部分），第二个值是余数。\n对于3.x，参数不能是复数 x 可以为整数/浮点数，y 也如此\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a=13 b=3 x,y=divmod(a,b) print(x,y) # 4 1 a=13.6 b=3 x,y=divmod(a,b) print(x,y)\t# 4.0 1.5999999999999996 print(x,round(y,1))\t# 4.0 1.6 a=13.6 b=3.1 x,y=divmod(a,b) print(x,y)\t# 4.0 1.1999999999999993 应用场景\n进制转换\n1 2 3 4 5 6 7 8 def int_to_base(n, base): digits = [] while n \u0026gt; 0: n, rem = divmod(n, base)\t# 除留余数法 digits.append(rem)\t# 余数先存进去，是低位 return digits[::-1]\t# 逆序 print(int_to_base(42, 16)) # [2, 10] 表示 0x2A 时间单位转换\n1 2 3 4 total_seconds = 7541 hours, rem = divmod(total_seconds, 3600) minutes, seconds = divmod(rem, 60) print(f\u0026#34;{hours}:{minutes}:{seconds}\u0026#34;) # 2:5:41 循环缓冲区处理，类似哈希表的“线性法直接mod”\n1 2 3 4 5 6 buffer_size = 1024 write_pos = 1500 # 计算实际写入位置 chunk, offset = divmod(write_pos, buffer_size) print(f\u0026#34;写入第 {chunk} 个缓冲区的 {offset} 位置\u0026#34;) id id()函数返回对象的唯一标识符，标识符是一个整数。\nCPython 中 id() 函数获取的是对象的内存地址。（python3.9——CPython3.9）\n1 2 3 4 5 a=13 b=3 print(id(a)) # 3054276471472 print(id(b))\t# 3054276471152 print(type(id(a)))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 拓展：不同的python\n需要最佳兼容性 → CPython （主，兼容性最好，标准）\n与 Java 生态整合 → Jython\n需要 .NET 互操作 → IronPython\n追求高性能 → PyPy\n嵌入式开发 → MicroPython\nobject object()：不接收任何参数，返回一个空对象 1 2 3 4 5 6 x = object() print(dir(x)) # [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, # \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, # \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, # \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;] object() 的核心价值：\n所有类的基类：提供默认行为\n轻量级对象：用于简单场景\n方法继承：提供默认的 __str__、__eq__ 等方法\nsorted sorted() 对 所有可迭代的对象 进行排序操作。\nsort 与 sorted 区别：\nsort 是 list 的方法，sorted 可对所有可迭代的对象应用。\nlist 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\nsorted(iterable, key=None, reverse=False)，三个参数，依次是 可迭代变量、选择内层元素的函数方法、升序or降序。\n1 2 3 4 ls=[(3,2),(1,4),(5,3),(2,6)] new_ls=sorted(ls,key=lambda x:x[0],reverse=True)\t# 对象为列表 ls，方法是 通过首层元素的第0个元素排序，True-\u0026gt;降序 print(ls)\t# [(3, 2), (1, 4), (5, 3), (2, 6)] print(new_ls)\t# [(5, 3), (3, 2), (2, 6), (1, 4)]\t得到 5 3 2 1 降序 ascii ascii(object) ，返回object的字符串，对于字符串中的非 ASCII 字符则通过 repr() 函数使用 \\x, \\u 或 \\U 编码。\n1 2 3 4 a=[[1,2,3],[3,4,5]] b=ascii(a) print(type(b)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; print(b.split(\u0026#39;,\u0026#39;)) # [\u0026#39;[[1\u0026#39;, \u0026#39; 2\u0026#39;, \u0026#39; 3]\u0026#39;, \u0026#39; [3\u0026#39;, \u0026#39; 4\u0026#39;, \u0026#39; 5]]\u0026#39;] enumerate enumerate(seq, [start=0])\n将seq的元素挨个取出和0,1,2,3\u0026hellip;.组成二元组，各个二元组组成enumerate类型，enumerate不可索引。\n1 2 3 4 5 6 7 8 seasons=[[1,2,3],[4,5,6]] print(type(enumerate(seasons)))\t# \u0026lt;class \u0026#39;enumerate\u0026#39;\u0026gt; for i, element in enumerate(seasons): print(i, element)\t# 0 [1, 2, 3]\t1 [4, 5, 6] for j in enumerate(seasons): print(type(j))\t# \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; print(j[0],j[1])\t# 0 [1, 2, 3] break （主）同时获取索引 i，和元素本身element：\n1 2 for i, element in enumerate(seasons): print(i, element) input input([prompt]) ：在命令行提示prompt，然后接收命令行输入的信息为字符串。\n1 2 a = input(\u0026#34;input:\u0026#34;) type(a) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 和strip、map结合\n1 2 3 4 5 6 7 # strip() 去掉文末空格 a=input(\u0026#39;输入：\u0026#39;).strip()\t# 输入“123 ”\t去掉文末空字符 print(len(a))\t# 3 a=input(\u0026#39;输入：\u0026#39;)\t# 输入“123 ”\t不去掉文末空字符 print(len(a))\t# 4 b=list(map(int, input(\u0026#39;输入：\u0026#39;).split())) # 输入“1 2 3”\t输出[1,2,3] 标准空白字符 字符名称 转义序列 空格 \\x20 水平制表符（Tab） \\t 换行符（LF） \\n 回车符（CR）（Mac 换行) \\r 垂直制表符 \\v 换页符 \\f staticmethod @staticmethod 用于定义静态方法的装饰器，返回函数的静态方法。\n1 2 3 4 class C(object): @staticmethod def add(a, b): return a + b 特点：\n代码中的add函数不能有“self”（实例引用）和“cls”类引用 是类命名空间中的函数，不需要实例便可调用 不能直接访问实例属性或类属性，因为无self/cls 静态方法与普通方法对比\n特征 普通方法 静态方法 第一个参数 self（实例引用） 非self非类 调用方式 实例调用 类/实例均可调用 访问权限 可访问实例属性 仅能访问传入参数 1 2 3 4 5 6 7 class MyClass: def normal_method(self): print(f\u0026#34;实例方法：{self}\u0026#34;) # 依赖实例 @staticmethod def static_method(): print(\u0026#34;静态方法\u0026#34;) # 无依赖 bin bin() 输入：一个整数 int 或者长整数 long int。返回：二进制的字符串。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a=3 print(bin(a))\t# 0b11 print(type(bin(a)))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; for i in bin(a): print(i)\t# 0\\nb\\n1\\n1\\n help(bin) # bin(number, /) # Return the binary representation of an integer. # # \u0026gt;\u0026gt;\u0026gt; bin(2796202) # \u0026#39;0b1010101010101010101010\u0026#39; open open(name[, mode[, buffering]])\n1 2 3 4 5 # 例子 with open(\u0026#39;_20_data.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: # 读取数据 N\\n1 2 3 n = int(file.readline().strip()) data = list(map(int, file.read().split())) w从头写 r只读 a追加\n读写方式 是否为 二进制 是否为 可读可写 r 空 空 w b + a 共\t3*2*2=12种\n模式对照表\n模式 描述 文件存在 文件不存在 指针位置 r+ 读写（文件必须存在） 不清空，从指针位置“覆盖写” 报错 开头 w+ 写读（清空后读写） 必定清空，从指针位置写 创建 开头 a+ 追加读写 必定从末尾写 创建 末尾 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 创建文件 with open(\u0026#39;test_r+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;旧内容\u0026#39;) # r+ try:\t# 不存在改文件会报错 with open(\u0026#39;test_r+.txt\u0026#39;, \u0026#39;r+\u0026#39;) as f: print(f.read()) # 输出: 旧内容^ （^指针位置） f.seek(0)\t# ^旧内容\t（移动指针位置到开头） f.write(\u0026#39;新\u0026#39;) # 新^内容\t（从指针位置覆盖写入） f.seek(0)\t# ^新内容 print(f.read()) # 输出: 新内容 except FileNotFoundError: print(\u0026#34;文件不存在\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建文件 with open(\u0026#39;test_w+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;原始内容\u0026#39;) # w+ with open(\u0026#39;test_w+.txt\u0026#39;, \u0026#39;w+\u0026#39;) as f: f.write(\u0026#39;全新内容\u0026#39;) # 清空后写入 全新内容^ f.seek(0)\t# 移动指针到开头\t^全新内容 print(f.read()) # 输出: 全新内容 # 文件不存在时 import os with open(\u0026#39;new_w+.txt\u0026#39;, \u0026#39;w+\u0026#39;) as f: f.write(\u0026#39;创建内容\u0026#39;)\tf.seek(0) print(os.path.abspath(\u0026#39;new_w+.txt\u0026#39;)) # 输出: 创建的文件的绝对路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 创建文件 with open(\u0026#39;test_a+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;初始行\\n\u0026#39;) # a+ with open(\u0026#39;test_a+.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;追加行\\n\u0026#39;) # 追加行\\n^ f.seek(0) # ^初始行\\n追加行\\n print(f.read()) # 输出: 初始行\\n追加行\\n # 验证指针特性 f.seek(5) # 初始行\\n追^加行\\n f.write(\u0026#39;中间插入\u0026#39;) # 仍然追加到文件末尾！ f.seek(0) print(f.read()) # 输出: 初始行\\n追加行\\n中间插入 eval eval(表达式的字符串[, globals[, locals]])，执行一个字符串表达式，并返回表达式的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 简单表达式 result = eval(\u0026#34;2 + 3 * 4\u0026#34;) print(result) # 输出: 14 # 变量引用 x = 10 result = eval(\u0026#34;x + 5\u0026#34;) print(result) # 输出: 15 # 指定变量空间 namespace = {\u0026#39;a\u0026#39;: 2, \u0026#39;b\u0026#39;: 3}\t# 必须是字典 result = eval(\u0026#34;a + b\u0026#34;, namespace) print(result) # 输出: 5 eval() 执行代码有安全风险，可能导致代码注入漏洞，并确保仅执行可信任的字符串表达式。 设置命名空间的内置函数和类型 —— __builtins__\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 安全沙箱环境配置 safe_globals = { \u0026#39;__builtins__\u0026#39;: { \u0026#39;abs\u0026#39;: abs, \u0026#39;max\u0026#39;: max, \u0026#39;min\u0026#39;: min, \u0026#39;pow\u0026#39;: pow, \u0026#39;round\u0026#39;: round } } # 安全计算示例 result = eval(\u0026#34;pow(2, 3) + abs(-5)\u0026#34;, safe_globals) # 输出: 13 # 危险操作示例（将被阻止） try: eval(\u0026#34;open(\u0026#39;test.txt\u0026#39;)\u0026#34;, safe_globals) except NameError as e: print(f\u0026#34;安全拦截: {e}\u0026#34;) # 输出: name \u0026#39;open\u0026#39; is not defined 拓展: __builtins__\n1 2 3 4 5 6 7 # 查看内置函数列表 print(dir(__builtins__)) # 输出: [\u0026#39;ArithmeticError\u0026#39;, \u0026#39;AssertionError\u0026#39;, ...,\u0026#39; iter\u0026#39;, \u0026#39;len\u0026#39;, \u0026#39;license\u0026#39;, \u0026#39;list\u0026#39;, \u0026#39;locals\u0026#39;, \u0026#39;map\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;memoryview\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;next\u0026#39;, \u0026#39;object\u0026#39;, \u0026#39;oct\u0026#39;, \u0026#39;open\u0026#39;, ...] # 调用内置函数 print(__builtins__.len([1,2,3])) # 输出: 3 print(len([1,2,3])) # 等价 int int(x, base=10) -\u0026gt; integer，将一个数字或字符串转为一个int类型数据, 如果没有参数返回0。\n1 2 3 4 5 6 print(int(3.6))\t# 输出3，小数点后直接删了 print(int(\u0026#39;1a\u0026#39;,16)) # 如果带参数base的话，第一个参数一定要是字符串，12 为 16进制，输出26 # 此处出现字母默认是16进制 # 也就是说提供了其他进制转换到10进制的内置函数 print(int(\u0026#39;0xaa\u0026#39;,16))\t# 16 * 10 + 1 * 10 = 70 print(int(\u0026#39;0b110\u0026#39;,2))\t# 4+2=6 int([x]) -\u0026gt; integer，[x]可以是str, bytes, or bytearray 且符合该进制（由base确定）的字面量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with open(\u0026#39;test.txt\u0026#39;,\u0026#39;wb+\u0026#39;) as f: f.write(b\u0026#39;12\u0026#39;)\t# 写入bytes类型内容 f.seek(0) byte_ls=f.readline()\t# 读取bytes print(byte_ls)\t# b\u0026#39;12\u0026#39; print(type(byte_ls))\t# \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; int_ls=int(byte_ls)\t# 默认10进制转换 print(int_ls)\t# 12 print(type(int_ls))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; int_ls=int(byte_ls, 8)\t# 设置为8进制 print(int_ls)\t# 10 ","date":"2025-02-21T00:00:00Z","image":"https://rooobeam.github.io/p/python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/rz0sefu53fe_hu_359b55b65c1f5167.webp","permalink":"https://rooobeam.github.io/p/python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","title":"Python3内置函数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # deepseek-r1生成后删减得来 import sys import platform import subprocess from importlib.metadata import distributions def get_environment_info(): env_info = { # 系统信息 \u0026#34;操作系统\u0026#34;: f\u0026#34;{platform.system()} {platform.release()} {platform.version()}\u0026#34;, \u0026#34;系统架构\u0026#34;: platform.architecture()[0], \u0026#34;主机名\u0026#34;: platform.node(), # Python环境 \u0026#34;Python版本\u0026#34;: sys.version.replace(\u0026#39;\\n\u0026#39;, \u0026#39; \u0026#39;), \u0026#34;虚拟环境\u0026#34;: \u0026#34;是\u0026#34; if hasattr(sys, \u0026#39;real_prefix\u0026#39;) or sys.prefix != sys.base_prefix else \u0026#34;否\u0026#34;, # 包管理信息 \u0026#34;已安装包\u0026#34;: [f\u0026#34;{dist.metadata[\u0026#39;Name\u0026#39;]}=={dist.version}\u0026#34; for dist in distributions()], } # 获取conda信息（如果可用） try: result = subprocess.run([\u0026#39;conda\u0026#39;, \u0026#39;list\u0026#39;], capture_output=True, text=True, check=True) env_info[\u0026#34;Conda包列表\u0026#34;] = result.stdout.splitlines() except: env_info[\u0026#34;Conda包列表\u0026#34;] = \u0026#39;conda list fail\u0026#39; pass return env_info if __name__ == \u0026#34;__main__\u0026#34;: info = get_environment_info() # 打印摘要信息 print(\u0026#34;=\u0026#34; * 50 + \u0026#34;\\n环境配置摘要:\\n\u0026#34; + \u0026#34;=\u0026#34; * 50) print(f\u0026#34;操作系统: {info[\u0026#39;操作系统\u0026#39;]}\u0026#34;) print(f\u0026#34;Python版本: {info[\u0026#39;Python版本\u0026#39;].split(\u0026#39; [\u0026#39;)[0]}\u0026#34;) print(f\u0026#34;虚拟环境: {info[\u0026#39;虚拟环境\u0026#39;]}\u0026#34;) print(f\u0026#34;已安装包数量: {len(info[\u0026#39;已安装包\u0026#39;])}\u0026#34;) # 保存完整信息到文件 with open(\u0026#34;environment_report.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: for key, value in info.items(): f.write(f\u0026#34;\\n=== {key} ===\\n\u0026#34;) if isinstance(value, list): f.write(\u0026#39;\\n\u0026#39;.join(value)) elif isinstance(value, dict): for k, v in value.items(): f.write(f\u0026#34;{k}: {v}\\n\u0026#34;) else: f.write(str(value)) print(\u0026#34;\\n完整环境报告已保存到 environment_report.txt\u0026#34;) ","date":"2025-02-21T00:00:00Z","image":"https://rooobeam.github.io/p/%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84txt/preview%281%29_hu_f70373dca115e4ca.jpg","permalink":"https://rooobeam.github.io/p/%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84txt/","title":"生成当前环境配置的txt"},{"content":"寄存器（内存访问） ✅\n(⊙﹏⊙) ","date":"2025-02-19T21:22:11+08:00","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%95%96%E5%85%89_hu_ca55c6edaf6ec37c.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/","title":"汇编语言第三章"},{"content":"第一个程序 ✅\n源程序写出到执行简要过程，后文有实例： 编写源程序 —— 写一个文本文件 —— 使用edit、笔记本等。 编译连接 —— 用汇编语言编译程序对文本文件编译产生目标文件；再用连接程序对目标文件进行连接，生成可执行文件。 在操作系统中执行文件。 ✅\n源程序简单结构 1 2 3 4 5 6 7 8 9 10 11 12 13 assume 寄存器:某segment段, 寄存器:某segment段, 寄存器:某segment段 XXX segment : : : XXX ends YYY segment : mov ax,4c00H int 21H YYY ends end 伪指令：提供给编译器的，编译器根据伪指令进行编译工作。上面代码中assume，XXX segment……XXX ends 和 end。 标号，如segment段的名称 上面代码中的XXX、YYY，一个标号指代一个地址。 程序返回：将CPU的控制权还给 使他得以运行的程序（shell)。代码中的 mov ax,4C00H \\n int 21H 。 ✅\n实例\n编写源程序 svg\n​\t桌面右键新建txt命名123，记事本里写好源程序。\n编译 svg\nwin+R 输入command打开命令提示符，输入“cd masm”（masm.exe所在目录），输入“masm”启动masm.exe。 提示我们输入源文件名，txt文件放在了c:\\asm，且不是asm文件，输入c:\\asm\\123.txt。 询问生成obj文件名，我们选择默认，回车即可。 提示输入列表文件名，该文件为编译为目标文件的中间结果，我们不生成，回车即可。 提示输入交叉引用文件名，也是中间结果，不生成，回车即可。 无错误则masm.exe所在目录下生成123.obj 连接 svg\n进入DOS方式(win+R 输command)，进入c:/masm (Overlay Linker3.60，link.exe所在目录),输入link启动link.exe。 提示输入目标文件名，[.OBJ]提示默认扩展名为obj，正合我意，输入123即可。 提示生成的exe文件名，默认名就行，回车即可。 提示输入映像文件名，提示输入库文件名，我们都回车即可。 无error则当前目录下生成123.exe。 执行，命令行输入文件名就行了，masm.exe 或 masm 123.exe 或 123 。\ndebug跟踪程序的运行过程：debug 可以将程序载入内存，设置CS:IP指向程序的入口，但debug不放弃cpu的控制权\n具体方法：debug 123.exe svg 运用第二章的debug的使用方法 R命令查看、改变寄存器内容 D查看内存中内容 E改写内存内容 U将内存中机器指令(01\u0026hellip;)翻译以为汇编命令(mov\u0026hellip;) T执行一条机器指令 A以汇编指令格式往内存写入机器指令 P正常结束程序。 实操如下图： svg ✅\nexe执行过程与shell DOS中，123.exe若要运行，要有一个正在运行的程序p2将其载入内存，123.exe运行完后即将cpu控制权交还程序p2。 p2即command.com，被成为命令解释器，即DOS系统的shell。输入cd、dir、type等都由command执行。 提示符\u0026quot;c:\\masm“后输入123.exe，此时command.com运行。 输入123.3exe后，command根据文件名找到该可执行文件，将程序载入内存，设置CS:IP指向程序入口，随后执行程序。 执行完回到command。 dos中.exe的加载过程（上面第二步——载入内存） 找到SA:0000空闲内存区——\u0026gt;前256即偏移地址0-255创程序段前缀(PSP)，DOS要用它和.exe通信——\u0026gt;后面装入程序，即从SA+10H:0000——\u0026gt;CS:IP=SA+10H:0000 加载.svg ✅\n习题 习题.svg ","date":"2025-02-19T00:00:00Z","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%B8%89%E9%BE%99_hu_87bde1cf9b7bc30f.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/","title":"汇编语言第四章"},{"content":"寄存器 ✅\n8086cpu有14个寄存器：AX BX CX DS SI DI SP BP IP CS SS DS ES PSW。\n8086cpu寄存器都是16位的。\nABCD-X通常用来存放一般性数据，被成为通用寄存器。\n寄存器?X可被分为?H和?L，如AX分为AH AL，即分为AHigh ALow，前者是高八位，后者是第八位。\n所谓高位和数字的高位联想，都是左边是高位。\n✅\n几条汇编指令：mov add，用法一样。add ax,18H; add ax,8H。\n数字默认16进制。\nmov ax,bx; mov ax,7。\n两个操作对象位数一致，第一个位置要是变量，如mov ah,bl; mov bh, AA。\n✅\n物理地址即内存在统一的逻辑存储器中的地址。\n内存地址空间:cpu将系统中各类存储器看作一个逻辑存储器。\n物理地址=段地址*16+偏移地址，通常写作 段地址:偏移地址，如cpu指令读取开始地址CS:IP。\n由于十六进制，故其实即 “段地址0+偏移地址”，由一个地址加法器合成。\n段的概念：段地址固定，偏移地址连续的内存空间。故其最大范围0000~FFFF。实践发现，0-1会自动变成FFFF，FFFF+1变成0000。\n✅\n8086有四个段寄存器：CS DS SS ES。\nCS和IP：CS叫代码 段寄存器，IP 叫指令指针寄存器，CS存段地址IP存偏移量。\ncpu将从CS:IP单元开始读取一条指令并执行。\n取指执行过程：从CS:IP读取指令，该指令进入指令缓冲器；IP=IP+该指令长度，从而指向下一指令首单元；执行指令；从CS:IP读取指令\u0026hellip;\u0026hellip;.\n修改CS IP命令——jmp jmp 段地址:偏移地址\t段地址修改CS 偏移地址修改IP jmp “四位数” 仅修改IP jmp 某合法寄存器\t仅修改IP，IP=某合法寄存器的值\n","date":"2025-02-12T22:10:35+08:00","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/vglcjtiwyh9bnm0o_hu_b0d85bfc829806f3.webp","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"汇编语言第二章"},{"content":"正文 设备：win2000VM虚拟机，win11宿主机\nwin11上：如何搭建FTP：https://zhuanlan.zhihu.com/p/36070173\nwin2000上：\n调为NAT模式； 我的电脑-\u0026gt;网上邻居-\u0026gt;地址栏输入ftp://宿主机wlan地址 搞定。\n？？？\n","date":"2025-02-05T13:08:00+08:00","permalink":"https://rooobeam.github.io/p/ftp%E5%AE%9E%E8%B7%B5/","title":"Ftp实践"},{"content":"","date":"2025-01-18T10:28:00+08:00","permalink":"https://rooobeam.github.io/p/newblog/","title":"Newblog"},{"content":"","date":"2025-01-18T09:50:26+08:00","permalink":"https://rooobeam.github.io/p/newtest/","title":"Newtest"},{"content":"hello hi fine 测试简体中文能否显示\n","date":"2025-01-17T19:46:01+08:00","permalink":"https://rooobeam.github.io/p/firstblog/","title":"FirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://rooobeam.github.io/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"https://rooobeam.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://rooobeam.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://rooobeam.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://rooobeam.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://rooobeam.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://rooobeam.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://rooobeam.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://rooobeam.github.io/p/emoji-support/","title":"Emoji Support"}]