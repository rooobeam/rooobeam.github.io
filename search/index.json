[{"content":" .pop(self,index)方法 1 2 3 a=[1,2,3] a.pop(1) print(a)\t# [1,3] 函数传实参还是形参问题\n在 Python 中，参数传递始终是 引用传递（传地址的）。但根据对象类型（可变/不可变）的不同，会产生类似「值传递」或「引用传递」的表象：\n结论：看对象类型\n不可变对象（字符串、数字、元组等）作为参数时： 形参接收到的是对象的引用 若在函数内修改形参，会创建新对象，实参不受影响（类似值传递） 可变对象（列表、字典、集合等）作为参数时： 形参接收到的也是对象的引用 若在函数内 原地修改 形参（如 append、+= 等操作），实参会同步变化（类似引用传递） 1 2 3 4 5 6 7 8 9 10 11 12 13 def f(obj): # 修改形参 obj += obj # 不可变对象（字符串） obj1 = \u0026#34;123456\u0026#34; demo(obj1) print(\u0026#34;函数调用后obj1:\u0026#34; + obj1) # 123456（未变） # 可变对象（列表） obj2 = [1,2,3] demo(obj2) print(\u0026#34;函数调用后obj2:\u0026#34; + str(obj2)) # [1,2,3,1,2,3]（已变） ","date":"2025-03-09T00:00:00Z","permalink":"https://rooobeam.github.io/p/py_coding_tricks/","title":"Py_coding_tricks"},{"content":"参考Linux 下如何调试 Python？ - hoxis - 博客园\n在命令行，将程序作为参数传递来调试，“\u0026hellip; -m pdb \u0026hellip;py”，—— 命令行传pdb方式\npython3 -m pdb test1.py\n1 2 3 4 root@autodl-container-c00844b981-267cf857:~/autodl-tmp/test_script# python3 -m pdb test1.py \u0026gt; /root/autodl-tmp/test_script/test1.py(3)\u0026lt;module\u0026gt;() -\u0026gt; def add(a, b): (Pdb) _\u0026lt;-光标在此处 在代码中import pdb，写pdb.set_trace()代码 —— import pdb 方式\nimport pdb\npdb.set_trace()\npython3 test1.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # -*- coding: utf-8 -*- import pdb def add(a, b): return a + b if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;===start===\u0026#34;) pdb.set_trace() c = add(1, 3) print(\u0026#34;===end===\u0026#34;) ======= 命令行情况如下 ======== root@autodl-container-c00844b981-267cf857:~/autodl-tmp/test_script# python3 test1.py ===start=== \u0026gt; /root/autodl-tmp/test_script/test1.py(9)\u0026lt;module\u0026gt;() -\u0026gt; c = add(1, 3) (Pdb) 进入调试后常用指令\n(Pdb) l\t（“小写L指令”：查看）（若连续输入两次，则第二次返回[EOF]）\n(Pdb) l\n(Pdb) l\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ===========\t命令行传pdb root@autodl-container-c00844b981-267cf857:~/autodl-tmp/test_script# python3 -m pdb test1.py \u0026gt; /root/autodl-tmp/test_script/test1.py(3)\u0026lt;module\u0026gt;() -\u0026gt; def add(a, b): (Pdb) 1 1 # -*- coding: utf-8 -*- 2 3 -\u0026gt; def add(a, b): 4 return a + b 5 6 if __name == \u0026#39;__main__\u0026#39;: 7 print(\u0026#34;==start==\u0026#34;) 8 c = add(1, 3) 9 print(\u0026#34;==end==\u0026#34;) [EOF] (Pdb) b 8 Breakpoint 1 at /root/autodl-tmp/test_script/test1.py:8 (Pdb) b 9 Breakpoint 2 at /root/autodl-tmp/test_script/test1.py:9 (Pdb) b Num Type Disp Enb Where 1 breakpoint keep yes at /root/autodl-tmp/test_script/test1.py:8 2 breakpoint keep yes at /root/autodl-tmp/test_script/test1.py:9 (Pdb) c ===start=== \u0026gt; /root/autodl-tmp/test_script/test1.py(8)\u0026lt;module\u0026gt;() -\u0026gt; c = add(1, 3) (Pdb) c \u0026gt; /root/autodl-tmp/test_script/test1.py(9)\u0026lt;module\u0026gt;() -\u0026gt; print(\u0026#34;===end==\u0026#34;) (Pdb) p c 4 (Pdb) p a *** NameError: name \u0026#39;a\u0026#39; is not defined (Pdb) p b *** NameError: name \u0026#39;b\u0026#39; is not defined (Pdb) s ===end=== --Return- \u0026gt; /root/autodl-tmp/test_script/test1.py(9)\u0026lt;module\u0026gt;()-\u0026gt;None -\u0026gt; print(\u0026#34;===end==\u0026#34;) (Pdb) s --Return- \u0026gt; \u0026lt;string\u0026gt;(1)\u0026lt;module\u0026gt;()-\u0026gt;None (Pdb) s \u0026gt; /root/miniconda3/lib/python3.12/bdb.py(604)run() -\u0026gt; self.guitting = True (Pdb) s The program finished and will be restarted ","date":"2025-03-08T19:56:00+08:00","permalink":"https://rooobeam.github.io/p/linux%E5%91%BD%E4%BB%A4%E8%A1%8Cpy%E8%B0%83%E8%AF%95/","title":"Linux命令行py调试"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 assume cs:codesg data segment db \u0026#39;1975\u0026#39;,\u0026#39;1976\u0026#39;,\u0026#39;1977\u0026#39;,\u0026#39;1978\u0026#39;,\u0026#39;1979\u0026#39;,\u0026#39;1980\u0026#39;,\u0026#39;1981\u0026#39;,\u0026#39;1982\u0026#39;,\u0026#39;1983\u0026#39; db \u0026#39;1984\u0026#39;,\u0026#39;1985\u0026#39;,\u0026#39;1986\u0026#39;,\u0026#39;1987\u0026#39;,\u0026#39;1988\u0026#39;,\u0026#39;1989\u0026#39; dd 16,22,345,4567,6475,4567,12345,34526,65734,465436,234234 dd 123345,463654,867887,1567689 dw 4,13,76,89,99,345,567,789,890,1234,5467 dw 6789,12345,14357,16776 data ends table segment db 15 dup (\u0026#39;year summ ne ?? \u0026#39;) table ends codesg segment start: ;set sreg (segment register) mov ax,data mov ds,ax mov ax,table mov es,ax ;set reg (register) mov bx,0 ;bx add 4 bytes mov si,0 ;si add 2 bytes mov bp,0 ;bp add 16 bytes mov cx,0fh s: ;year mov ax,[bx] ;30th row mov es:[bp+0],ax mov ax,2[bx] mov es:[bp+2],ax ;sum of money mov ax,60[bx] ;low -\u0026gt; ax mov es:[bp+5],ax mov dx,62[bx] ;high -\u0026gt; dx mov es:[bp+7],dx ;n of employee mov di,120[si] mov es:[bp+10],di ;?? —— average money div di mov es:[bp+13],ax add bx,4h add bp,10h add si,2h loop s mov ax,4c00h int 21h codesg ends end start ","date":"2025-03-06T00:00:00Z","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AB%E7%AB%A0/","title":"汇编语言第八章"},{"content":"（BFS and DFS） in tree search 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def invertTree(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: # 排除root为空的情况 if not root: return root # 队列 \u0026lt;——\u0026gt; list que=[root]\t# 循环条件：队列不为空 while que: # 出队 tnode=que.pop(0) # 如果左子树存在，入队 if tnode.left: que.append(tnode.left) # 如果右子树存在，入队 if tnode.right: que.append(tnode.right) # 将开头出队的左右子树换位 a=tnode.right tnode.right=tnode.left tnode.left=a return root #关键在于，队列初始化、出入队操作，以及存在才入队。 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -\u0026gt; bool: p_ls=[p] q_ls=[q] while(p_ls): p_n=p_ls.pop(0) q_n=q_ls.pop(0) if (p_n is None and q_n is not None or q_n is None and p_n is not None): return False if p_n: if p_n.val!=q_n.val: return False p_ls.append(p_n.left) p_ls.append(p_n.right) q_ls.append(q_n.left) q_ls.append(q_n.right) return True 给你一个二叉树的根节点 root ，一层一层地打印并标明位置，包括空结点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 在 104. 二叉树的最大深度 测试的 class Solution: def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: print(root) return q = [(root, 0)] # 初始化队列 cnt = 1 # 初始化第一层要分析的结点数 n_lay = 1 # 当前层的位置总个数 while q: n=cnt # 该层 还要 分析结点数，不停地减一 cp_cnt=cnt # 该层 结点总数 cnt=0 # 清零保存下层结点数 # 遍历当前层 while (n): tnode=q.pop(0) # (root,0) (Treenode,int) if tnode[0]: q.append((tnode[0].left,tnode[1]*2+0)) q.append((tnode[0].right,tnode[1]*2+1)) cnt+=2 print(tnode[0].val,tnode[1],end=\u0026#39;\\t\u0026#39;) else: print(tnode[0], tnode[1],end=\u0026#39;\\t\u0026#39;) n-=1 print() n_lay*=2 return 给你一个二叉树的根节点 root ， 检查它是否轴对称。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 # 暴力标出行点位 # 变量说明 # q: que 队列\tcnt: 记录某层存在的结点的个数\tn_lay: 当前层总位置数，即2^k个，k=0,1,2... # n: 当前层未分析的结点个数，初始为cnt，然后-1-1-1... # cp_cnt: 记录当前层的结点总个数，初始和n一样，只不过不会变化 # stack: 栈，进栈一半结点后，开始分析对称性时，通过出栈互消除 class Solution: def isSymmetric(self, root: Optional[TreeNode]) -\u0026gt; bool: if not root: return True q=[(root,0)]\t# 队列 cnt=1 # 初始化第一层要分析的结点数 n_lay=1 # 当前层的位置总个数 while(q): n=cnt # 该层 还要 分析结点数，不停地减一 cp_cnt=cnt # 该层 结点总数 cnt=0 # 清零保存下层结点数 stack=[] # 遍历当前层 while (n): tnode=q.pop(0) if n\u0026lt;=cp_cnt/2: # 出栈 pop_node=stack.pop(-1) # 都是真，核对位置和值 if tnode[0] and pop_node[0]: if tnode[0].val!=pop_node[0].val: print(\u0026#39;A\u0026#39;) return False if (tnode[1]+pop_node[1])!=n_lay-1: print(\u0026#39;B\u0026#39;) return False # 排除了都是真，但不都None，则必为一真一None elif tnode[0] or pop_node[0]: print(\u0026#39;C\u0026#39;) return False else: # 都是None，核对位置 if (tnode[1]+pop_node[1])!=n_lay-1: print(\u0026#39;D\u0026#39;) return False # 都是None则已经出栈完成互消 else: stack.append(tnode) if tnode[0]: q.append((tnode[0].left,tnode[1]*2+0)) q.append((tnode[0].right,tnode[1]*2+1)) cnt+=2 n-=1 n_lay*=2 return True 1 2 3 4 5 6 7 8 9 # 递归 class Solution: def isSymmetric(self, root: Optional[TreeNode]) -\u0026gt; bool: def recur(L, R): if not L and not R: return True if not L or not R or L.val != R.val: return False return recur(L.left, R.right) and recur(L.right, R.left) return not root or recur(root.left, root.right) 二叉树的最大深度 给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n两种思路：自顶向下 和 自底向上\n自顶向下：顶层为1，向下加一并取最大返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # 自顶向下 class Solution: def recur(self,tnode:Optional[TreeNode],dep:int)-\u0026gt;int: if not tnode: return dep-1 else: return max(self.recur(tnode.left, dep+1), self.recur(tnode.right, dep+1)) def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: return self.recur(root,1) 自底向上：最底空结点为0，一直向上加，太惊艳了\n“我在网上看到一种理解递归的说法：「在写递归函数时，可以假设递归返回的结果一定是正确的」。其实这种说法本质上就是数学归纳法。”——作者\n代码中 max(l_depth, r_depth) + 1 就是假设l_depth 和 r_depth是正确的，然后本层则为 max(l_depth, r_depth) + 1\n​\tif root is None: ​ return 0 ​ l_depth = self.maxDepth(root.left) ​ r_depth = self.maxDepth(root.right) 则保证了初始状况也是正确的，刚才的假设便成立，就能得到正确结果。\nhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/2010612/kan-wan-zhe-ge-shi-pin-rang-ni-dui-di-gu-44uz/\n1 2 3 4 5 6 7 8 # 自底向上 class Solution: def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if root is None: return 0 l_depth = self.maxDepth(root.left) r_depth = self.maxDepth(root.right) return max(l_depth, r_depth) + 1 ","date":"2025-03-04T00:00:00Z","permalink":"https://rooobeam.github.io/p/tree-search/","title":"Tree Search"},{"content":"","date":"2025-03-03T00:00:00Z","permalink":"https://rooobeam.github.io/p/binary_search/","title":"Binary_search"},{"content":"☝内存单元 、\u0026quot;()\u0026quot;、 loop 和 idata [bx]\n类似[0]，[bx]表示 ds:bx上的字节单元或字单元的内存内容，bx内的4位作为偏移地址\n[0] [bx] mov ax, [0] 将地址为ds:0 的内存字单元存入ax mov ax, [bx] 将地址为ds:bx的内存单元存入ax mov al, [0] 将地址为ds:0 的内存半字单元存入al mov al, [bx] 将地址为ds:bx的内存半字单元存入al 实例 问题5.1.svg\n1 忘了要写啥了 “()\u0026quot;，机组中“(地址)”——描述某地址上的内容\n()中的元素有三种类型： 寄存器名，段寄存器名 和 五位十六进制的物理地址\n如 (ax)、(al)、(ds)、(20000H)、**((ds)*16+(bx))**注意里面的ds、bx都有括号\nax=10000H，则(ax)=(10000H)即地址10000H上的字节单元或字单元\nloop 类似“goto”\n1 2 3 4 5 6 7 8 9 10 assume cs:code code segment cx=8 s:\tax=0 loop s mov ax,4c00h int 21 code ends end ​\t首先(cx)=(cx)-1，然后判断(cx)是否等于0，如果等于0则执行下一指令，如果不等于0则跳转到s处执行。\nloop 可能情境 cx初始化8，循环8次后继续执行 cx为人为初始化，然后为0，(cx)=(cx)-1变成大数(如65535) cx设置指令在循环体内，死循环 idata\n约定符号好idata表示常量，mov ax,[idata]代表mov ax,[1]、mov ax,[2]等。\n又如 mov ds,idata 都是非法指令\n☝实验四 程序 编程，向内存0:2000:23F依次传送数据063(3FH)，程序中只能使用9条指令，9条指令中包括‘mov ax,4c00h’和‘int 21h’。\n在常见的x86汇编语言（如MASM、NASM）中，分号 ; 是标准的行注释符号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 assume cs:codesg codesg segment mov ax,020H\tmov ds,ax\t; 初始化ds，不能直接将数字传入段寄存器 mov bx,0H\t; 初始化bx因为从0 mov cx,40H\t; cx=40H即循环64次存入数据0~63 s:\t; 标记loop跳转位置 mov [bx],bl\t; 内存0:200~0:23F是40H个字节数据,要存入字节数据，bl存入cs:bx的字节单元，因为要对应bl的大小是1字节 inc bx\t; 把bx+=1 移动偏移地址 loop s\t; 减小cx, 检查判断是否跳转 mov ax,4c00H\tint 21H\t; 结束 codesg ends end ☝实验五倒二题 编写code段中的代码，将a段和b段中的数据依次相加，将结果保存到c段中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 assume cs:code a segment db 1,2,3,4,5,6,7,8 ; a 原始数据 a ends b segment db 1,2,3,4,5,6,7,8 ; b 原始数据 b ends c segment db 0,0,0,0,0,0,0,0 ; c 结果存储区 c ends code segment start: mov bx,0\t; 初始化偏移，从0开始 mov cx,8\t; 设置好循环次数 s:\tmov dx,a\tmov ds,dx\t; ds=a mov al,[bx]\t; al=a[bx] mov dx,b\tmov ds,dx\t; ds=b add al,[bx]\t; al= mov dx,c\tmov ds,dx\t; ds=c mov [bx],al\t; c[bx]=al=a[bx]+b[bx] inc bx\t;bx++ loop s\t;跳转 mov ax,4c00h\tint 21h\t; 程序退出 code ends end start\t# 指明程序的开始结尾，start处设置cs=start 创建txt，将上述代码写入，保存。 win+R进入DOS，输入\u0026quot;cd masm5\u0026quot;，再输入\u0026quot;masm\u0026quot;启动。 源文件输入 \u0026ldquo;file_name.txt\u0026rdquo; 然后四个回车 没有error后，输入\u0026quot;link\u0026quot;，obj文件输入file_name，然后回车回车回车 输入\u0026quot;debug file_name.exe\u0026quot;，进入对该exe的debug模式 输入\u0026quot;u\u0026quot;查看当前能看到的指令，看不到\u0026quot;mov ax,4c00H\u0026quot;就输入t执行一条指令，输入个三四个再输入\u0026quot;u\u0026quot;查看，总之看到结束指令的偏移地址bx 输入\u0026quot;g bx\u0026quot;，直接执行到bx处 输入\u0026quot;r\u0026quot;，查看DS，因为它是c段的首地址，因为最后一次设置DS就是用的c 实验中ds=0c25，输入“d 0c25:0\u0026quot;便能查看c处的值是不是2 4 6 8\u0026hellip;，或者输入\u0026quot;d 0c23:0\u0026quot;能对比a、b、c段的内容。 db、dw：定义数据，db即define bytes，dw即define words， ☝实验五最后一题 编写code段代码，用push指令将a段中的前8个字型数据，逆序存储到b段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 assume cs:code a segment ; 数据段a dw 1,2,3,4,5,6,7,8,0ah,0bh,0ch,0dh,0fh,0ffh a ends b segment ; 数据段b dw 0,0,0,0,0,0,0,0 b ends code segment start: mov ax, a ; 赋值ds为a段的段地址 mov ds, ax mov ax, b ; 赋值堆栈段ss为b段的段地址 mov ss, ax mov sp,10h\t;偏移到堆栈最后的字型数据后，8个字，16个字节，0c24:0~0c24:0f，ss:sp指向0c24:10，即前者加一。 mov bx, 0 ; 初始化偏移量 mov cx, 8 ; 循环次数 s: push [bx] ; 将a段第i个字型数据存入b段倒数第i个字单元内 add bx, 2h ; 按字 (word) 处理数据，故+2 loop s mov ax, 4c00h ; 退出程序 int 21h code ends end start 读代码代码后思考：各种段是如何安排的，怎么让CPU会把dode段当作代码段\n❌\ncode data stack等段名如何设置只是为了方便阅读，不能起到修改cs ds ss的作用\nassume cs:code,ds:data,ss:stack 也不能\n✅\n程序末尾end start可以设置程序入口CS:IP\n✅\nmov ax,stack\nmov ss,ax\nmov sp,20h\n设置堆栈段，stacK是你设置的作为堆栈段的段名，可以是a、c what ever you want 符合一定命名规范即可。\n✅\nmov ax,data\nmov ds,ax\n设置数据段\n每个段势必占据N行，即：\n前一个段最后一个字节单元为所在行被前一个段占有，当前段从下一行开始，每行16字节。\n前一个段最后一个字节单元 a:b，则当前段的第一个字节单元为a+[b/10h]+1:0，[ ]取整数，10h十六个字节\na:b=2:34h\ta+[34h/10h]+1:0=2+3+1:0=6:0\n","date":"2025-02-22T00:00:00Z","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250222101607_hu_56fa5440ce86c489.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E5%85%AD%E7%AB%A0/","title":"汇编语言第五、六章"},{"content":"目录 abs dict help min、max setattr getattr all、any dir hex、oct next slice divmod id object sorted ascii enumerate input staticmethod bin open eval int str abs abs(x) 返回数字的绝对值。 x 可以是整数，浮点数，复数；如果是复数，则返回它的大小。\n1 2 3 4 a=abs(-50) print(a) b=abs(3 + 4j ) print(b) dict class dict(**kwarg) 等号模式 class dict(mapping, **kwarg) zip模式 class dict(iterable, **kwarg) 二元组列表 主要是zip模式和二元元组模式\n1 2 3 4 5 6 7 8 9 x = dict() # 创建空字典{} y = dict(a=\u0026#39;a\u0026#39;, b=\u0026#39;b\u0026#39;, t=\u0026#39;t\u0026#39;) # 传入关键字，等于号模式 z = dict(zip([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;], [1, 2, 3])) # 映射函数方式，zip模式 u = dict([(\u0026#39;one\u0026#39;, 1), (\u0026#39;two\u0026#39;, 2), (\u0026#39;three\u0026#39;, 3)]) # 可迭代对象方式，二元元组代替等号模式，二元列表元素会警告 print(x, y, z, u) # 也可直接用{}、:创建字典 v = {123: \u0026#39;123\u0026#39;, 456: \u0026#39;456\u0026#39;} print(v, type(v)) help help([object])\tobject \u0026ndash; 对象；\n返回对象帮助信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 help(list) # 输出： # # Help on class list in module builtins: # class list(object) # | list(iterable=(), /) # | # | Built-in mutable sequence. # | # | If no argument is given, the constructor creates a new empty list. # | The argument must be an iterable if specified. # | # | Methods defined here: # | # ...... min、max 返回可迭代参数中的最小、最大元素。\n1 2 print (\u0026#34;min(80, 100, 1000) : \u0026#34;, min(80, 100, 1000)) print (\u0026#34;min(80, 100, 1000) : \u0026#34;, max(80, 100, 1000)) setattr、getattr (attr——attribute)\nsetattr用于设置对象的属性值，getattr用于获取对象的属性值。相比于 \u0026ldquo;.\u0026rdquo; 功能更丰富。\n当实例a有属性bar时，当使用setattr(a, \u0026lsquo;bar\u0026rsquo;, 5)时，会将实例a属性bar设置为5; 当实例a无属性bar时，会为实例a创建一个实例属性bar，赋值为5，而类属性不变。 getattr当属性不存在时避免抛出AttributeError，若设置默认值，则不会报错。例如，getattr(a, \u0026lsquo;baz\u0026rsquo;, \u0026lsquo;default\u0026rsquo;)会返回\u0026rsquo;default\u0026rsquo;，而a.baz则会引发异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A(object): bar = 1 a = A() print(getattr(a, \u0026#39;bar\u0026#39;)) # 获取属性 bar 值 setattr(a, \u0026#39;bar\u0026#39;, 5) setattr(a, \u0026#39;weight\u0026#39;, 5) # 设置属性 weight 值，不存在会为该对象创建，但类不变 print(a.bar, a.weight) b=A() try: print(getattr(b, \u0026#39;weight\u0026#39;)) except AttributeError as e: print(f\u0026#34;属性访问错误: {e}\u0026#34;)\t# 为对象创建，但类不变，b无weight属性 print(getattr(b, \u0026#39;weight\u0026#39;，-1))\t# 设置默认值，返回-1不报错 all 、any all(iterable, /)\n判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 元素除了是 0、空、None、False 外都算 True。 空元组、空列表返回值为True，这里要特别注意。 不会进入内层。 1 2 3 print(all([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;])) # 元素都不为空或0，True print(all([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;d\u0026#39;])) # 存在一个为空的元素，False print(all([[\u0026#39;\u0026#39;],[\u0026#39;\u0026#39;]]))\t# 不会进入内层，首层元素[\u0026#39;\u0026#39;]不为0、空、None、False any(iterable, /) True False 与 all相反，其他都一样。 dir dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表 带参数时——dir([object])，返回参数的属性、方法列表。 如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。 1 2 3 4 5 6 7 8 9 10 class MyClass: def __init__(self): self.public_attr = 10 self.__private_attr=20 def normal_method(self): pass obj = MyClass()\t# 实例化对象 print(dir(obj)) 输出包含 \u0026lsquo;_MyClass__private_attr\u0026rsquo;, \u0026rsquo;normal_method\u0026rsquo;, \u0026lsquo;public_attr\u0026rsquo;\n[ \u0026lsquo;_MyClass__private_attr\u0026rsquo;, \u0026lsquo;__class__\u0026rsquo;, \u0026lsquo;__delattr__\u0026rsquo;, \u0026lsquo;__dict__\u0026rsquo;, \u0026lsquo;__dir__\u0026rsquo;, \u0026lsquo;__doc__\u0026rsquo;, \u0026hellip;\u0026hellip; \u0026lsquo;normal_method\u0026rsquo;, \u0026lsquo;public_attr\u0026rsquo; ]\n实际应用场景\n快速查看对象内容 动态检查对象功能 限制暴露的接口（设置接口） 1 2 # 快速查看对象内容 print(dir()) # 查看字典的方法，如 keys, values, items 1 2 3 4 # 动态检查对象功能 obj = SomeClass() if \u0026#34;__iter__\u0026#34; in dir(my_object): print(\u0026#34;对象是可迭代的\u0026#34;) 1 2 3 4 5 6 7 8 9 10 # 限制暴露的接口（设置接口） class SecureAPI: def __init__(self): self._internal_data = 100 def __dir__(self): return [\u0026#34;public_method\u0026#34;] # 隐藏内部实现 def public_method(self): return \u0026#34;Safe data\u0026#34; 拓展：属性名以双下划线 __ 开头且不以双下划线结尾 —— 名称修饰，避免子类与父类的私有属性命名冲突，Python会自动将其转换为：_类名__属性名\t(如刚才的_MyClass__private_attr)\n1 2 3 4 5 6 7 8 class A: def __init__(self): self.__x = 1 # _A__x class B(A): def __init__(self): super().__init__() self.__x = 2 # _B__x hex 、oct hex(x)：将10进制int转为16进制且为字符串，0x为前缀。\n1 2 3 4 5 a=16 print(type(a))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; b=hex(a) print(b)\t# 0x10 print(type(b))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; hex(x)：将10进制int转为8进制且为字符串，0o为前缀。\n1 2 3 4 a=16 b=hex(a) print(b)\t# 0o20 print(type(b))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; next next()返回迭代器的的下一个项目；要和生成迭代器函数 iter() 配合使用。 1 next(iterable[, default]) 一个参数是iter()生成的迭代器实例，另一个是默认值，如果指针超出范围就输出默认。\n我理解的next()是python 内置的__next__方法，因为iter类有__next__方法，而其他的如生成器也有，自定义一个类并定义__next__方法，该类弄出的实例也可以用next()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 自定义迭代器 class MyClass: # 迭代相关 __iter__(self) # 迭代：for i in obj __next__(self) # 下一个：next(obj) # 生成器（本身就是迭代器） # \u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; 不是 \u0026lt;class \u0026#39;list\u0026#39;\u0026gt;，用括号的 gen = (x for x in range(3))\tprint(next(gen)) # 0 print(next(gen)) # 1 # 文件对象（本身就是迭代器） with open(\u0026#39;data.txt\u0026#39;) as f: print(next(f)) # 直接读取第一行 print(next(f)) # 读取第二行 拓展 这样有双下划线的方法和无双下划线的有什么区别？如__getitem__(self)。 —— Python 的特殊方法（魔术方法）是由 Python 语言规范定义的。这些方法与 Python 的内置操作直接关联： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MyClass: # 基本操作 __init__(self) # 实例化：obj = MyClass() __str__(self) # 字符串转换：str(obj) __len__(self) # 长度：len(obj) # 迭代相关 __iter__(self) # 迭代：for i in obj __next__(self) # 下一个：next(obj) # 运算符 __add__(self) # 加法：obj + other __sub__(self) # 减法：obj - other # 容器操作 __getitem__(self) # 索引访问：obj[key] __setitem__(self) # 索引赋值：obj[key] = value # 使用这些特殊方法 lst = MyList() len(lst) # 调用 __len__ 3 in lst # 调用 __contains__ 判断是否contain for x in lst: ... # 调用 __iter__ # 查看所有特殊方法 # 方法1：查看内置文档 help(object) # 方法2：dir() 函数 print([m for m in dir(object) if m.startswith(\u0026#39;__\u0026#39;)]) slice slice()返回一个切片对象。\nslice(stop) slice(start, stop[, step])，(起点，终点，步长)\n直接使用 创建slice [:5] slice(None, 5) / slice(None, 5) [3::2] slice(3, None, 2) [::-1] slice(None, None, -1) 类似于a​:b:c\n1 2 3 4 5 a=list(range(10)) print(lst[2:7:2]) print(slice(2, 7, 2)) assert lst[2:7:2] == lst[slice(2, 7, 2)] 但是要保存为对象的话:\n1 2 x=2:7:2\t# ❌ 非法写法 x=slice(2, 7, 2)\t# ✅ 正确写法\t对于 lst[slice(95, 105, 2)]，为什么不用 lst[95:105:2] ? —— 定义slice的优势\n动态参数配置\n1 2 3 4 5 6 7 def dynamic_slicer(config): \u0026#34;\u0026#34;\u0026#34;根据外部配置生成切片\u0026#34;\u0026#34;\u0026#34; return data[slice(*config)] # 从配置文件读取参数 config = json.loads(\u0026#39;{\u0026#34;start\u0026#34;: 95, \u0026#34;stop\u0026#34;: 105, \u0026#34;step\u0026#34;: 2}\u0026#39;) print(dynamic_slicer(config.values())) # 动态应用切片参数 切片对象复用\n1 2 3 4 5 6 # 定义标准切片规则 DOWNSAMPLE_SLICE = slice(None, None, 4) # 每4个元素取1个 # 复用切片 video_frames = raw_frames[DOWNSAMPLE_SLICE] audio_samples = raw_audio[DOWNSAMPLE_SLICE] 多维切片基础\n1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(arr[0:2, 1:3]) # 输出 [[2 3], [5 6]] # 定义行和列的切片对象 row_slice = slice(0, 2) # 第0行到第1行（不含2） col_slice = slice(1, 3) # 第1列到第2列（不含3） print(arr[row_slice, col_slice]) # 输出 [[2 3], [5 6]] divmod divmod() 函数接受两个参数 x y（通常是两个数字），返回二元组，第一个值是 x 除以 y 的商（即整数部分），第二个值是余数。\n对于3.x，参数不能是复数， x 可以为整数/浮点数，y 也如此\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a=13 b=3 x,y=divmod(a,b) print(x,y) # 4 1 a=13.6 b=3 x,y=divmod(a,b) print(x,y)\t# 4.0 1.5999999999999996 print(x,round(y,1))\t# 4.0 1.6 a=13.6 b=3.1 x,y=divmod(a,b) print(x,y)\t# 4.0 1.1999999999999993 应用场景\n进制转换\n1 2 3 4 5 6 7 8 def int_to_base(n, base): digits = [] while n \u0026gt; 0: n, rem = divmod(n, base)\t# 除留余数法 digits.append(rem)\t# 余数先存进去，是低位 return digits[::-1]\t# 逆序 print(int_to_base(42, 16)) # [2, 10] 表示 0x2A 时间单位转换\n1 2 3 4 total_seconds = 7541 hours, rem = divmod(total_seconds, 3600) minutes, seconds = divmod(rem, 60) print(f\u0026#34;{hours}:{minutes}:{seconds}\u0026#34;) # 2:5:41 循环缓冲区处理，类似哈希表的“线性法直接mod”\n1 2 3 4 5 6 buffer_size = 1024 write_pos = 1500 # 计算实际写入位置 chunk, offset = divmod(write_pos, buffer_size) print(f\u0026#34;写入第 {chunk} 个缓冲区的 {offset} 位置\u0026#34;) id id()函数返回对象的唯一标识符，标识符是一个整数。\nCPython 中 id() 函数获取的是对象的内存地址。（python3.9——CPython3.9）\n1 2 3 4 5 a=13 b=3 print(id(a)) # 3054276471472 print(id(b))\t# 3054276471152 print(type(id(a)))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 拓展：不同的python\n需要最佳兼容性 → CPython （主，兼容性最好，标准）\n与 Java 生态整合 → Jython\n需要 .NET 互操作 → IronPython\n追求高性能 → PyPy\n嵌入式开发 → MicroPython\nobject object()：不接收任何参数，返回一个空对象 1 2 3 4 5 6 x = object() print(dir(x)) # [\u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, # \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, # \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, # \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;] object() 的核心价值：\n所有类的基类：提供默认行为\n轻量级对象：用于简单场景\n方法继承：提供默认的 __str__、__eq__ 等方法\nsorted sorted() 对 所有可迭代的对象 进行排序操作。\nsort 与 sorted 区别：\nsort 是 list 的方法，sorted 可对所有可迭代的对象应用。\nlist 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\nsorted(iterable, key=None, reverse=False)，三个参数，依次是 可迭代变量、选择内层元素的函数方法、升序or降序。\n1 2 3 4 ls=[(3,2),(1,4),(5,3),(2,6)] new_ls=sorted(ls,key=lambda x:x[0],reverse=True)\t# 对象为列表 ls，方法是 通过首层元素的第0个元素排序，True-\u0026gt;降序 print(ls)\t# [(3, 2), (1, 4), (5, 3), (2, 6)] print(new_ls)\t# [(5, 3), (3, 2), (2, 6), (1, 4)]\t得到 5 3 2 1 降序 sorted\u0026lt;-\u0026gt;sort reversed\u0026lt;-\u0026gt;reverse\nascii ascii(object) ，返回object的字符串，对于字符串中的非 ASCII 字符则通过 repr() 函数使用 \\x, \\u 或 \\U 编码。\n1 2 3 4 a=[[1,2,3],[3,4,5]] b=ascii(a) print(type(b)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; print(b.split(\u0026#39;,\u0026#39;)) # [\u0026#39;[[1\u0026#39;, \u0026#39; 2\u0026#39;, \u0026#39; 3]\u0026#39;, \u0026#39; [3\u0026#39;, \u0026#39; 4\u0026#39;, \u0026#39; 5]]\u0026#39;] enumerate enumerate(seq, [start=0])\n将seq的元素挨个取出和0,1,2,3\u0026hellip;.组成二元组，各个二元组组成enumerate类型，enumerate不可索引。\n1 2 3 4 5 6 7 8 seasons=[[1,2,3],[4,5,6]] print(type(enumerate(seasons)))\t# \u0026lt;class \u0026#39;enumerate\u0026#39;\u0026gt; for i, element in enumerate(seasons): print(i, element)\t# 0 [1, 2, 3]\t1 [4, 5, 6] for j in enumerate(seasons): print(type(j))\t# \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; print(j[0],j[1])\t# 0 [1, 2, 3] break （主）同时获取索引 i，和元素本身element：\n1 2 for i, element in enumerate(seasons): print(i, element) input input([prompt]) ：在命令行提示prompt，然后接收命令行输入的信息为字符串。\n1 2 a = input(\u0026#34;input:\u0026#34;) type(a) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 和strip、map结合\n1 2 3 4 5 6 7 # strip() 去掉文末空格 a=input(\u0026#39;输入：\u0026#39;).strip()\t# 输入“123 ”\t去掉文末空字符 print(len(a))\t# 3 a=input(\u0026#39;输入：\u0026#39;)\t# 输入“123 ”\t不去掉文末空字符 print(len(a))\t# 4 b=list(map(int, input(\u0026#39;输入：\u0026#39;).split())) # 输入“1 2 3”\t输出[1,2,3] 标准空白字符 字符名称 转义序列 空格 \\x20 水平制表符（Tab） \\t 换行符（LF） \\n 回车符（CR）（Mac 换行) \\r 垂直制表符 \\v 换页符 \\f staticmethod @staticmethod 用于定义静态方法的装饰器，返回函数的静态方法。\n1 2 3 4 class C(object): @staticmethod def add(a, b): return a + b 特点：\n代码中的add函数不能有“self”（实例引用）和“cls”类引用 是类命名空间中的函数，不需要实例便可调用 不能直接访问实例属性或类属性，因为无self/cls 静态方法与普通方法对比\n特征 普通方法 静态方法 第一个参数 self（实例引用） 非self非类 调用方式 实例调用 类/实例均可调用 访问权限 可访问实例属性 仅能访问传入参数 1 2 3 4 5 6 7 class MyClass: def normal_method(self): print(f\u0026#34;实例方法：{self}\u0026#34;) # 依赖实例 @staticmethod def static_method(): print(\u0026#34;静态方法\u0026#34;) # 无依赖 bin bin() 输入：一个整数 int 或者长整数 long int。返回：二进制的字符串。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a=3 print(bin(a))\t# 0b11 print(type(bin(a)))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; for i in bin(a): print(i)\t# 0\\nb\\n1\\n1\\n help(bin) # bin(number, /) # Return the binary representation of an integer. # # \u0026gt;\u0026gt;\u0026gt; bin(2796202) # \u0026#39;0b1010101010101010101010\u0026#39; open open(name[, mode[, buffering]])\n1 2 3 4 5 # 例子 with open(\u0026#39;_20_data.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: # 读取数据 N\\n1 2 3 n = int(file.readline().strip()) data = list(map(int, file.read().split())) w从头写 r只读 a追加\n读写方式 是否为 二进制 是否为 可读可写 r 空 空 w b + a 共\t3*2*2=12种\n模式对照表\n模式 描述 文件存在 文件不存在 指针位置 r+ 读写（文件必须存在） 不清空，从指针位置“覆盖写” 报错 开头 w+ 写读（清空后读写） 必定清空，从指针位置写 创建 开头 a+ 追加读写 必定从末尾写 创建 末尾 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 创建文件 with open(\u0026#39;test_r+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;旧内容\u0026#39;) # r+ try:\t# 不存在改文件会报错 with open(\u0026#39;test_r+.txt\u0026#39;, \u0026#39;r+\u0026#39;) as f: print(f.read()) # 输出: 旧内容^ （^指针位置） f.seek(0)\t# ^旧内容\t（移动指针位置到开头） f.write(\u0026#39;新\u0026#39;) # 新^内容\t（从指针位置覆盖写入） f.seek(0)\t# ^新内容 print(f.read()) # 输出: 新内容 except FileNotFoundError: print(\u0026#34;文件不存在\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建文件 with open(\u0026#39;test_w+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;原始内容\u0026#39;) # w+ with open(\u0026#39;test_w+.txt\u0026#39;, \u0026#39;w+\u0026#39;) as f: f.write(\u0026#39;全新内容\u0026#39;) # 清空后写入 全新内容^ f.seek(0)\t# 移动指针到开头\t^全新内容 print(f.read()) # 输出: 全新内容 # 文件不存在时 import os with open(\u0026#39;new_w+.txt\u0026#39;, \u0026#39;w+\u0026#39;) as f: f.write(\u0026#39;创建内容\u0026#39;)\tf.seek(0) print(os.path.abspath(\u0026#39;new_w+.txt\u0026#39;)) # 输出: 创建的文件的绝对路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 创建文件 with open(\u0026#39;test_a+.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;初始行\\n\u0026#39;) # a+ with open(\u0026#39;test_a+.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;追加行\\n\u0026#39;) # 追加行\\n^ f.seek(0) # ^初始行\\n追加行\\n print(f.read()) # 输出: 初始行\\n追加行\\n # 验证指针特性 f.seek(5) # 初始行\\n追^加行\\n f.write(\u0026#39;中间插入\u0026#39;) # 仍然追加到文件末尾！ f.seek(0) print(f.read()) # 输出: 初始行\\n追加行\\n中间插入 eval eval(表达式的字符串[, globals[, locals]])，执行一个字符串表达式，并返回表达式的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 简单表达式 result = eval(\u0026#34;2 + 3 * 4\u0026#34;) print(result) # 输出: 14 # 变量引用 x = 10 result = eval(\u0026#34;x + 5\u0026#34;) print(result) # 输出: 15 # 指定变量空间 namespace = {\u0026#39;a\u0026#39;: 2, \u0026#39;b\u0026#39;: 3}\t# 必须是字典 result = eval(\u0026#34;a + b\u0026#34;, namespace) print(result) # 输出: 5 eval() 执行代码有安全风险，可能导致代码注入漏洞，并确保仅执行可信任的字符串表达式。 设置命名空间的内置函数和类型 —— __builtins__\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 安全沙箱环境配置 safe_globals = { \u0026#39;__builtins__\u0026#39;: { \u0026#39;abs\u0026#39;: abs, \u0026#39;max\u0026#39;: max, \u0026#39;min\u0026#39;: min, \u0026#39;pow\u0026#39;: pow, \u0026#39;round\u0026#39;: round } } # 安全计算示例 result = eval(\u0026#34;pow(2, 3) + abs(-5)\u0026#34;, safe_globals) # 输出: 13 # 危险操作示例（将被阻止） try: eval(\u0026#34;open(\u0026#39;test.txt\u0026#39;)\u0026#34;, safe_globals) except NameError as e: print(f\u0026#34;安全拦截: {e}\u0026#34;) # 输出: name \u0026#39;open\u0026#39; is not defined 拓展: __builtins__\n1 2 3 4 5 6 7 # 查看内置函数列表 print(dir(__builtins__)) # 输出: [\u0026#39;ArithmeticError\u0026#39;, \u0026#39;AssertionError\u0026#39;, ...,\u0026#39; iter\u0026#39;, \u0026#39;len\u0026#39;, \u0026#39;license\u0026#39;, \u0026#39;list\u0026#39;, \u0026#39;locals\u0026#39;, \u0026#39;map\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;memoryview\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;next\u0026#39;, \u0026#39;object\u0026#39;, \u0026#39;oct\u0026#39;, \u0026#39;open\u0026#39;, ...] # 调用内置函数 print(__builtins__.len([1,2,3])) # 输出: 3 print(len([1,2,3])) # 等价 int int(x, base=10) -\u0026gt; integer，将一个数字或字符串转为一个int类型数据（10进制）, 如果没有参数返回0。 如果带参数base的话，第一个参数一定要是字符串\n1 2 3 4 5 6 7 8 9 #小数点后直接删了 print(int(3.6))\t# 3 # 如果带参数base的话，第一个参数一定要是字符串。1a为 16进制。 print(int(\u0026#39;1a\u0026#39;,16)) # 26 # int被print时都是10进制，int其他进制字符串转为10进制表示的int print(int(\u0026#39;0xaa\u0026#39;,16))\t# 16 * 10 + 1 * 10 = 70 print(int(\u0026#39;0b110\u0026#39;,2))\t# 4+2=6 int([x]) -\u0026gt; integer，[x]可以是str, bytes, or bytearray 且符合该进制（由base确定）的字面量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 with open(\u0026#39;test.txt\u0026#39;,\u0026#39;wb+\u0026#39;) as f: # 写入bytes类型内容 f.write(b\u0026#39;12\u0026#39;)\tf.seek(0) # 读取bytes byte_ls=f.readline()\tprint(byte_ls)\t# b\u0026#39;12\u0026#39; print(type(byte_ls))\t# \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; # 默认10进制转换 int_ls=int(byte_ls)\tprint(int_ls)\t# 12 print(type(int_ls))\t# \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; # 设置为8进制 int_ls=int(byte_ls, 8)\tprint(int_ls)\t# 10 str str(object=\u0026rsquo;\u0026rsquo;)，返回一个对象的字符串。\n1 print(type(str(123)))\t# \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 对比str()和ascii()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dict = {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;} # 转换一些数据结构是一样的 print(str(dict))\t# {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;} print(ascii(dict))\t# {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;} # 对于字符串数据，str不会将\u0026#39;转字符串里，ascii严格转 s = \u0026#39;rooobeam\u0026#39; print(str(s))\t# RUNOOB print(ascii(s))\t# \u0026#39;RUNOOB\u0026#39; # 对于非ASCII字符，str没事，转义为Unicode码点 ss = \u0026#39;阿道夫\u0026#39; print(str(ss))\t# 阿道夫 print(ascii(ss))\t# \u0026#39;\\u963f\\u9053\\u592b\u0026#39; 输出目标 非ASCII字符处理 字符处理 特殊字符转义 主要用途 str 人类可读的字符串 原样 无 仅转义控制字符如\\n 用户友好 ascii Python可解析str Unicode码点(如\\u4e2d) 始终用单引号包裹 转义所有非ASCII字符 调试和安全 bool bool(x) 将给定参数转换为布尔类型，如果没有参数，返回 False。\n1 2 3 print(bool(0))\t# False print(bool(1))\t# Ture print(bool(2))\t# True （bool是int的子类，然并卵。）\nReturns True when the argument x is true, False otherwise.\nexec exec(object[, globals[, locals]])，执行储存在字符串或文件中的 Python 语句，可执行更复杂的 Python 代码。\n1 2 3 4 exec(\u0026#39;\u0026#39;\u0026#39; print(\u0026#34;where you are\u0026#34;) print(\u0026#34;where is love\u0026#34;) \u0026#39;\u0026#39;\u0026#39;) globals，locals类似 eval。\n非常不安全，永远不要执行没有检验过的代码。\n可用__builtins__限制命名空间。\nisinstance isinstance(object, classinfo)——isinstance(实例a, 类A)，判断实例a 是不是 A 或 A的子类 的实例化。\n1 2 3 4 a = 2 isinstance(a,int)\t# True a是int类型 isinstance(a,str)\t# False\ta不是str类型 isinstance(a,(str,int,list)) # True 元组里有a的类型 isinstance() 与 type() 区别：\ntype() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。\n1 2 3 4 5 6 7 8 a = bool() print(type(a)==int)\t# False # 子类是父类的一种，a是子类则a是父类 print(isinstance(a,int))\t# True # 反之不成立 b = int() print(isinstance(b,bool))\t# False ord、chr ord(c)，c为字符，返回 Unicode 码点 (十进制int) for a one-character string.\n1 2 3 4 print(ord(\u0026#39;a\u0026#39;))\t# 97 print(ord(\u0026#34;a\u0026#34;))\t# 97 print(ord(\u0026#39;€\u0026#39;)) # 8364 print(type(ord(\u0026#39;a\u0026#39;)))\t# int chr(i) ，ord的反向操作 返回一个one-character string 对应输入的unicode码点(十进制int)， 0 \u0026lt;= i \u0026lt;= 0x10ffff (unicode的最大码点).\n1 2 3 print(chr(65)) # \u0026#39;A\u0026#39;（65对应\u0026#39;A\u0026#39;） print(chr(9731)) # \u0026#39;☃\u0026#39;（9731对应雪人符号） print(type(chr(9731)))\t# str sum 对iterable的元素求和\n1 2 3 print(sum([1,2,3]),sum((1,2,3)),sum({1,2,3})) # 6 6 6 print(sum(1,2,3),1)\t# 7\t组计算总和后再加 1 bytes、bytearray 初始化空bytearray、bytes bytearray() -\u0026gt; empty bytes array bytes() -\u0026gt; empty bytes object 1 print(bytearray())\t# bytearray(b\u0026#39;\u0026#39;) 初始化n个 \\x00 bytearray(int) -\u0026gt; bytes array of size given by the parameter initialized with null bytes bytes() -\u0026gt; empty bytes object 1 2 print(bytearray(2))\t# bytearray(b\u0026#39;\\x00\\x00\u0026#39;) print(bytes(2))\t# b\u0026#39;\\x00\\x00\u0026#39; 转换int的可迭代类型（[1,2,3], (1,2,3), {1,2,3}等） bytearray(iterable_of_ints) -\u0026gt; bytearray bytes(iterable_of_ints) -\u0026gt; bytes 1 2 3 # 每个int范围 in range(256) print(bytearray([1,2,3,4]))\t# bytearray(b\u0026#39;\\x01\\x02\\x03\\x04\u0026#39;) print(bytes([1,2,3,4]))\t转换字符串类型 1 2 a=bytearray(\u0026#39;八寸\u0026#39;, \u0026#39;utf-8\u0026#39;) print(a)\t# bytearray(b\u0026#39;\\xe5\\x85\\xab\\xe5\\xaf\\xb8\u0026#39;) bytes、bytearray、memoryview 和其他自定义的缓冲区对象间相互转换 bytearray(bytes_or_buffer) -\u0026gt; mutable copy of bytes_or_buffer bytes(bytes_or_buffer) -\u0026gt; immutable copy of bytes_or_buffer 1 2 3 a=b\u0026#34;abc\u0026#34;\t# bytes类型 b=bytearray(a) print(b)\t# bytearray(b\u0026#39;abc\u0026#39;)\tbytearray类型 对比。\n不同：\n是否可修改\n使用 b\u0026rsquo;\u0026rsquo; 或 bytes() 创建还是使用 bytearray() 创建\nfile.read()得出的是bytes\n相同：\n存储内容：都存储字节数据（0到255之间的整数，\\x00~\\xff）。\n二进制数据：都适合处理二进制数据，如文件、网络通信等。\n索引和切片：都支持通过索引和切片访问数据。\n1 2 3 4 5 6 7 8 9 10 11 4ea=bytearray(\u0026#39;abc\u0026#39;, \u0026#39;utf-8\u0026#39;) b=bytes(\u0026#34;ABC\u0026#34;,\u0026#39;utf-8\u0026#39;) print(a[0])\t# 97 a[0]=65 print(a[0])\t# 65 try: b[0]=97 except Exception as e: print(f\u0026#34;{e}\u0026#34;)\t# \u0026#39;bytes\u0026#39; object does not support item assignment filter filter(function or None, iterable) \u0026ndash;\u0026gt; filter object filter 函数用于过滤序列，过滤掉不符合条件的元素，返回一个filter对象。接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，函数需返回 True 或 False，最后将返回 True 的元素放到filter中。 1 2 3 4 5 6 def is_odd(n): return n % 2 == 1 a = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) b = list(a) print(b)\t# [1, 3, 5, 7, 9] 如果function那里填了None，则返回非空元素。 1 2 3 a = filter(None ,[1, 2, 0, 4, \u0026#39;\u0026#39;, 6]) b = list(a) print(b)\t# [1, 2, 4, 6] filter 对象是惰性求值的，这点类似于生成器。\n一旦迭代过 filter 对象，其内容就会被消耗，无法再次使用。\n如果需要多次访问，可转换为列表或其他可迭代对象。\n1 2 3 4 5 6 7 8 def is_odd(n): return n % 2 == 1 a = filter(is_odd, [1, 2, 3]) for i in a: print(i)\t# 1\\n3\\n b=list(a) print(b)\t# [] issubclass issubclass(class1, class2)，判断 class1 是否为 class2 的子类。 1 2 3 4 5 6 class A: pass class B(A): pass print(issubclass(B,A)) # True pow pow(base, exp, mod=None)\tpow(底数，指数，模数=None)\n两个参数时，得到 base**exp，三个参数时，得到 base**exp % mod\n对于一些类型的参数如int型参数它能算得更快。\n1 2 3 4 5 6 7 # 两个参数 print(pow(2,3))\t# 8 print(pow(2.5,2))\t# 6.25 print(pow(2,2.5))\t# 5.656854249492381 # 三个参数 print(pow(2,34,13))\t# 10 super 一句话概括：调用父类方法，改变传入实例。\nsuper(class, obj )，class——指定从哪个类开始查找父类方法，obj——传入的对象\n译为 创建一个 传入了对象obj的 可调用class的父类的方法的 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Parent: def greet(self): print(\u0026#39;Parent\u0026#39;) class Child(Parent): def greet(self): print(\u0026#39;Child\u0026#39;) def react(self): print(\u0026#39;c\u0026#39;) # 在类外部调用父类方法 c = Child() super(Child, c).greet() # Parent 在一个类里，super()=super(当前类, self)，会自动绑定当前类和实例(self)，适用于类方法中。\n译为 创建一个 传入了self的 可调用当前类的父类的方法的 对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Parent(object): def __init__(self): # 定义传入的对象的属性 self.parent = \u0026#39;I\\\u0026#39;m the parent.\u0026#39;\t# 证明执行__init__方法的语句 print (\u0026#39;Parent\u0026#39;) def bar(self, message): # 证明可调用其他方法如bar print (\u0026#34;%s from Parent\u0026#34; % message) class Child(Parent): def __init__(self): # 调用parent的初始化函数，如继承父类属性 super().__init__() print (\u0026#39;Child\u0026#39;) def bar(self, message): super(Child, self).bar(message) print (\u0026#39;Child bar fuction\u0026#39;) print (self.parent) if __name__ == \u0026#39;__main__\u0026#39;: Child = Child() Child.bar(\u0026#39;HelloWorld\u0026#39;) # 输出 # Parent # Child # HelloWorld from Parent # Child bar fuction # I\u0026#39;m the parent. 可不可以理解为 super(Child,self) 首先找到 Child 的父类（Parent），然后把类 Child 的对象转换为类 Parent 的对象？ —— False\n可能会发生死循环吗？ —— True\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Parent: def __init__(self): # Parent 对象必有a属性 self.a=123\tdef react(self): self.react() class Child(Parent): def react(self): super().react() # 证明不是Parent的对象 try: print(b.a) except Exception as e: print(f\u0026#34;{e}\u0026#34;)\t# \u0026#39;super\u0026#39; object has no attribute \u0026#39;a\u0026#39; # 证明死循环 c = Child() b=super(Child, c) try: super(Child, c).react() except Exception as e: print(f\u0026#34;{e}\u0026#34;)\t# maximum recursion depth exceeded 多重继承问AI float 将一个字符串或整数转为浮点数\n1 2 3 float(123)\t# 123.0 float(\u0026#39;123\u0026#39;)\t# 123.0 float(\u0026#39;123.123\u0026#39;)\t# 123.123 iter iter() 用于获取可迭代对象的迭代器，两种传参：(iterable) 、(callable, sentinel)\niter(iterable) -\u0026gt; iterator\t传入可迭代对象，如列表、字符串，转为iter.\n（“给对象生成__iter__() 和 __next__()”）\n1 2 3 4 5 6 7 8 9 10 11 12 # 配合 next() 逐步获取元素时应用 a=iter(\u0026#34;123\u0026#34;) print(next(a))\t# 1 print(next(a))\t# 2 print(next(a))\t# 3 # iterator 惰性计算 print(list(a))\t# [] # 在for循环中隐式调用 a=iter(\u0026#34;123\u0026#34;) for i in a: print(i) iter(callable, sentinel) -\u0026gt; iterator，重复调用无参函数callable，直到其返回值等于sentinel（哨兵值）时停止 1 2 3 4 5 6 7 8 import random def get_random(): return random.randint(1, 10) it = iter(get_random, 7) for num in it: print(num) # 持续输出随机数，直到出现7时停止 拓展（__iter__）\nPython 的迭代器：实现 __iter__() 和 __next__() 方法的对象被视为迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Counter: def __init__(self, low, high): self.current = low self.high = high def __iter__(self): return self def __next__(self): if self.current \u0026gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1 # 使用 counter = Counter(1, 3) for num in counter: print(num) # 输出1, 2, 3 以后遇到了再补充了 print print(value, \u0026hellip;, sep=\u0026rsquo; \u0026lsquo;, end=\u0026rsquo;\\n\u0026rsquo;, file=sys.stdout, flush=False)\nsep间隔 默认一个空格，print完成后补充内容 默认一个换行符，输出文件 默认控制台，是否刷新缓存默认否。\n1 2 3 4 5 6 # sep print(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;, sep=\u0026#34;, \u0026#34;)\t# apple, banana, cherry # end for i in range(3): print(i, end=\u0026#34; | \u0026#34;) # 0 | 1 | 2 | （同一行） tuple tuple(iterable=(), /)，将可迭代对象转为元组类型，元组数据不可修改。 1 2 a=tuple([1,2,3]) print(a)\t# (1,2,3) 判断是否为可迭代对象 1 2 a=[1,2,3] print(\u0026#39;__iter__\u0026#39; in dir(a))\t# True callable callable（可调用对象）是指任何可以通过 () 运算符调用的对象。例如：函数、方法、类，或者实现了 call 方法的对象，是否具有__call__ 1 2 3 4 5 6 7 8 # 用 def 或 lambda 定义的函数是callable def greet(): print(\u0026#34;Hello!\u0026#34;) add = lambda x, y: x + y print(callable(greet))\t# True print(callable(add))\t# True 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 类本身是 callable （类可被调用来创建实例，但对象未必） class A: pass a=A() print(callable(A))\t# True print(callable(a))\t# False # 类里定义了__call__，这样得到的对象是callable （能实现b()） class B: def __call__(self): return 0 b=B() print(callable(b))\t# True print(b())\t# 0 1 2 3 4 5 6 7 8 9 # 对象的方法是 callable class A: def react(self): print(\u0026#34;great!\u0026#34;) a = A() print(callable(a.react))\t# True\t# a.react()不是callable，方法react没有返回一个有__call__的对象 print(callable(a.react())\t# False\t拓展：类装饰器（通过 __call__ 实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class countcalls: def __init__(self, func): self.func = func self.count = 0 def __call__(self, *args, **kwargs): # 类实例成为 Callable self.count += 1 print(f\u0026#34;函数已被调用 {self.count} 次\u0026#34;) return self.func(*args, **kwargs) @CountCalls # 装饰器相当于：say_hello=countcalls(say_hello) def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() # 输出：函数已被调用 1 次 → Hello! say_hello() # 输出：函数已被调用 2 次 → Hello! format、f-string 基础用法：基本替换、位置索引、传递变量值 1 2 3 4 5 6 7 8 9 10 11 12 13 # format text = \u0026#34;{} is {}\u0026#34;.format(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) print(text) # a is b text=\u0026#34;{1} is {0}\u0026#34;.format(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) print(text) # b is a c=123 text=\u0026#34;hi,{}\u0026#34;.format(c)\t# hi,123 ls=[\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;] text=\u0026#34;{0[0]} {0[1]}\u0026#34;.format(ls) print(text)\t# 1 2 1 2 3 # f-string name=八寸 text=f\u0026#34;i love {name}\u0026#34; 常用控制格式：小数位数、进制转换、小数转百分比\n特别是\tf\u0026quot;{num:2f}\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 小数位数控制 decimal=123.125 a=\u0026#34;2位：{decimal:.2f}\u0026#34; b=\u0026#34;3位：{:3f}\u0026#34;.format(decimal) # 进制 n = 255 print(\u0026#34;二进制: {:b}\u0026#34;.format(n)) # 二进制: 11111111 print(\u0026#34;十六进制: {n:x}\u0026#34;) # 十六进制: ff print(\u0026#34;十进制: {n:d}\u0026#34;) # 十进制: 255 print(\u0026#34;八进制: {:o}\u0026#34;.format(n)) # 八进制: 377 # 小数转百分比，百分号要放大括号{}里 rate = 0.8523 a = \u0026#34;完成度: {rate:.2%}\u0026#34; # 取整百分比 b= \u0026#34;完成度: {:.2}%\u0026#34;.format(rate) print(a) # 输出：完成度: 85.23% print(b) # 输出：完成度: 0.85% format或f-string下大括号用{{}}(双重大括号) 1 2 text = \u0026#34;格式占位符: {{}}\u0026#34;.format() print(text) # 格式占位符: {} 其他对齐、填充啥的要用再查就好了，太没用了 len 求各种序列的长度\n数据类型 len() 结果 字符串 字符个数（包括空格 \u0026quot; \u0026ldquo;、 \\t、\\n 等） 列表/元组 元素数量 字典 键值对数量 集合 元素数量 字节/字节数组 字节数量 自定义对象 取决于 __len__() 方法的实现 1 2 3 4 5 text = \u0026#34;Hello, 世界!\\n\u0026#34; # 包含英文、中文、符号、换行符 print(len(text)) # 11 ls=[[],[]] print(len(ls)) # 2 property property 的核心用途是将类的方法转换为“虚拟属性”，1 将方法伪装成\u0026quot;属性\u0026rdquo;， 优雅地控制\u0026quot;属性\u0026quot;。\n@property\t@ method.setter\t@method.deleter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Circle: def __init__(self, radius): self._radius = radius # 私有变量 self._pi = 3.141592653589793 @property # 通过方法返回变量，起到保护_radius作用（只读） def radius(self): return self._radius @property # 实时计算面积area def area(self): return self._pi*(self._radius**2) @radius.setter # 控制radius的修改 def radius(self, value): if value \u0026lt; 0: raise ValueError(\u0026#34;半径不能为负\u0026#34;) self._radius = value # 合法时存储 @radius.deleter # 控制radius的删除 def radius(self): print(\u0026#34;禁止删除半径！\u0026#34;) c = Circle(5) print(c.radius) # 5 print(c.area)\t# 78.53981633974483 对比 \u0026ldquo;.\u0026rdquo; 访问属性 和 使用property 场景 直接访问属性 使用 property 优势对比说明 数据校验 ❌ 无法验证 ✅ 通过 setter 控制 避免非法值赋值（如负半径） 动态计算属性值 ❌ 需手动计算 ✅ 实时计算（如 面积 = πr²） 属性值随依赖变量自动更新，无需额外调用方法 隐藏内部实现 ❌ 暴露变量名 ✅ 封装私有变量（如 _radius） 保护内部数据命名，外部仅通过属性接口访问 接口兼容性 ❌ 修改变量名会破坏外部调用 ✅ 外部仍用 obj.x，内部可自由修改 内部变量名可重构（如 _radius → _r），不影响外部调用，减少代码耦合性 type type(object) -\u0026gt; the object\u0026rsquo;s type\t返回对象的type，打印type会显示\u0026lt;\u0026hellip;.\u0026gt; 1 2 print(type(5)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; print(type(\u0026#34;hello\u0026#34;)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 是否考虑继承关系：type不承认，isinstance() 会认为子类是一种父类类型。\n即“a是A的实例，a是A的父类的实例吗”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A: pass class B(A): pass a=A() b=B() # 是子类 则 是父类 print( isinstance(B(), A) ) # True # 不承认 是子类则是父类 print( type(a) == type(b) ) # False # 是父类 不能判定 是子类 print( isinstance(A(), B) ) # False type(name, bases, dict, **kwds) -\u0026gt; a new type，了解，遇到了再补充 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 定义方法 def __init__(self, name): self.name = name def bark(self): return \u0026#34;Woof!\u0026#34; # 动态创建类 Dog = type( \u0026#39;Dog\u0026#39;, (), # 基类为空（默认继承 object） { \u0026#39;__init__\u0026#39;: __init__, \u0026#39;species\u0026#39;: \u0026#34;Canis familiaris\u0026#34;, \u0026#39;bark\u0026#39;: bark } ) set 集合 set() -\u0026gt; new empty set object 创建空集合，注意A={}创建的是空字典 1 2 3 4 a=set() b={} print(type(a),type(b))\t# \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; print(a,b)\t# set() {} set(iterable) -\u0026gt; new set object\t将可迭代数据变为集合，能起到去重效果 1 2 3 4 5 6 7 ls=[1,2,3,2] ns=set(ls) print(ns)\t# {1, 2, 3} s=\u0026#34;rooobeam\u0026#34; ns=set(s) print(ns)\t# {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;} 集合推导式 和 直接初始化 1 2 3 4 5 a={x for x in range(5)} print(a)\t# {0, 1, 2, 3, 4} b={1,2,3} print(b)\t# {1, 2, 3} 集合对象的方法 方法 作用 返回值/行为 add(element) 添加单个元素 原地修改集合，无返回值 remove(element) 删除指定元素（元素不存在时报错） 原地修改集合，元素不存在时抛 KeyError discard(element) 删除指定元素（元素不存在时不报错） 原地修改集合，无返回值 clear() 清空集合 原地清空集合，无返回值 s.update({4, 5}) → s 包含新元素 合并多个集合（原地修改） 原地修改集合，无返回值 s1.intersection_update(s2) 原地保留交集（仅保留共同元素） 原地修改集合，无返回值 s1.difference_update(s2) 原地保留差集（移除其他集合的元素） 原地修改集合，无返回值 s1.isdisjoint(s2) → True/False 判断两个集合是否无交集 返回 True/False s2 = s1.copy() → 生成独立副本 浅拷贝集合 返回新集合的浅拷贝（与原集合独立） frozenset 直译为 冻结集合\nfrozenset() -\u0026gt; empty frozenset object\n（ 空 frozenset 最重要的作用是 作为安全的不可变默认值，避免使用可变空集合如 set()时，因意外修改导致的程序逻辑错误 ）\n1 print(frozenset())\t# frozenset() frozenset(iterable) -\u0026gt; frozenset object\nBuild an immutable unordered collection of unique elements.\n创建一个 不可修改的 无序的 元素collection，元素有唯一性。\n将 可迭代数据 变成一个 冻结的集合\n1 2 3 4 5 6 7 ls=[1,2,3,2] fs=frozenset(ls) print(fs)\t# frozenset({1,2,3}) s=\u0026#34;hello\u0026#34; fs=frozenset(s) print(fs)\t# frozenset({\u0026#39;e\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;}) frozenset({A, B})类似一个“组合值”，可以作为字典的键或集合的元素（可哈希性） 1 2 3 4 5 6 7 fs = frozenset({1, 2}) dict = {fs: \u0026#34;1, 2\u0026#34;} print(dict[fs])\t# 1, 2 fs_set={fs,1} print(fs_set)\t# {1, frozenset({1, 2})} 支持集合操作 作用 方法 返回并集 fs1.union(fs2) → 同 `fs1 返回交集 fs1.intersection(fs2) → 同 fs1 \u0026amp; fs2 返回差集（A - B） fs1.difference(fs2) → 同 fs1 - fs2 判断是否为子集 fs1.issubset(fs2) → False 返回副本（与原对象相同） fs2=fs.copy() → 新 frozenset list list(iterable=(), /), 函数/操作 作用 示例 定义列表 创建列表 my_list = [1, \u0026quot;a\u0026quot;, True] 索引 访问单个元素（支持正负索引） my_list[0]，my_list[-1] 切片 截取子列表 my_list[1:3] 直接赋值 修改单个元素 my_list[0] = 100 切片赋值 修改或替换子列表 my_list[1:2] = [200, 300] append(x) 在末尾添加单个元素 list = [1,2]; list.append(3) extend(iterable) 合并可迭代对象到末尾 list = [1,2]; list.extend([3,4]) → [1,2,3,4] del list[0:2] 删除元素 list = [1,2,3]; del list[1] → [1,3] 列表推导式 生成列表 y=[x if x\u0026gt;1 else -1 for x in [1,2,3] ] sort() 原地排序 list = [3,1,2]; list.sort() reverse() 原地反转列表顺序 list = [1,2,3]; list.reverse() copy() 创建浅拷贝列表 new_list = list.copy() count(x) 统计元素 x 的出现次数 list = [1,2,2,3]; list.count(2) -\u0026gt; 2 index(x) 返回 x 第一次出现的索引 list = [1,2,2,3]; list.index(2) -\u0026gt; 1 浅拷贝 复制外层对象（嵌套共享引用） a = [[1,2],3]; b = a.copy() len(list) 返回列表长度 len([1,2,3]) max(list) 返回最大值 max([1,3,2]) min(list) 返回最小值 min([1,3,2]) sum(list) 对数值列表求和 sum([1,2,3]) any(list) 检查是否存在为 True 的元素 any([0, False, 1]) all(list) 检查是否所有元素为 True all([1, True, 0]) enumerate(list) 返回索引-值对的迭代器 list(enumerate([\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;])) 列表推导式 enumerate 同时获取 索引和元素 1 2 3 ls=[\u0026#34;i\u0026#34;,\u0026#34;love\u0026#34;,\u0026#34;you\u0026#34;] for i,elem in enumerate(ls): print(i,elem,end=\u0026#39; \u0026#39;)\t# 0 is i 1 is love 2 is you range range(end) -\u0026gt; [0, end,1) “从0开始，到end之前，包括0不包括end，步长为1” 1 2 for number in range(6): print(number,end=\u0026#39; \u0026#39;)\t# 0 1 2 3 4 5 range(start, end, step) -\u0026gt; [start, end, step) “从start开始，到end之前，包括start不包括end，步长为step” 1 2 for number in range(1, 6, 2): print(number,end=\u0026#39; \u0026#39;)\t# 1 3 5 range(start, end, -1) -\u0026gt; [start, end, -1) 从大到小的range，step为负值，start必须\u0026gt;=end 1 2 for number in range(6, 1, -2): print(number,end=\u0026#39; \u0026#39;)\t# 6 4 2 classmethod classmethod是一种装饰器，用于**@classmethod定义类方法**。 方法类型 装饰器 首个参数 访问权限 典型场景 实例方法 无 self 实例属性、类属性 操作实例数据 类方法 @classmethod cls 类属性、其他类方法 工厂方法、操作类状态 静态方法 @staticmethod 无 无法访问类属性、实例属性 工具函数，与类逻辑相关但不依赖数据 用于需要访问或修改类状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A(object): bar = 1 def func1(self): print (\u0026#39;hi\u0026#39;) @classmethod def func2(cls): print (\u0026#39;func2\u0026#39;) # 访问类属性 print (cls.bar) # 调用 类中的普通方法 cls().func1() A.func2() # 不需要实例化 实现工厂模式 —— 类方法创建对象，比如，根据文件扩展名（如.json、.xml、.csv）创建相应的解析器对象，封装了 所支持的格式 的 类属性、获取特定格式对象 的 类方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Parser: _supported_formats = [\u0026#34;.json\u0026#34;, \u0026#34;.xml\u0026#34;, \u0026#34;.csv\u0026#34;] @classmethod def create_parser(cls, file_path): # 访问类属性获取支持格式 for fmt in cls._supported_formats: if file_path.endswith(fmt): return cls._get_parser_by_format(fmt) raise ValueError(\u0026#34;Unsupported format\u0026#34;) @classmethod def _get_parser_by_format(cls, fmt): # 调用其他类方法 if fmt == \u0026#34;.json\u0026#34;: return JsonParser() elif fmt == \u0026#34;.xml\u0026#34;: return XmlParser() elif fmt == \u0026#34;.csv\u0026#34;: return CsvParser() # 调用 parser = Parser.create_parser(\u0026#34;data.json\u0026#34;) repr repr(obj, /)\t返回对象的规范字符串，用于明确描述对象状态。\n始终为自定义类定义__repr__，避免默认的\u0026lt;ClassName object at 0x...\u0026gt;输出。优先使用\nf-string生成返回值。\nprint()时 或 交互式环境中输入对象名时（如\u0026gt;\u0026gt;\u0026gt; obj） 调用obj的__repr__输出相关信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A: def __init__(self, x): self.x = x def __repr__(self): return f\u0026#34;x={self.x}\u0026#34; # 明确且可还原的表示 a = A(3) print(a) # x=3 print(repr(a)) # x=3 class B: def __init__(self, x): self.x = x b=B(7) print(b)\t# \u0026lt;__main__.B object at 0x000001893F4A6E80\u0026gt; zip zip(*iterables) ，*iterables表名可有多个可迭代对象，返回一个元素为元组的 zip 对象，以最短的可迭代对象为终点。 1 2 3 4 5 6 7 8 9 10 a = [1,2,3] b = [4,5,6] c = [4,5,6,7,8] zip_ab = zip(a,b) print(list(zip_ab)) # [(1, 4), (2, 5), (3, 6)] # 元素个数与最短的列表一致 zip_ac = zip(a,c) print(list(zip_ac)) # [(1, 4), (2, 5), (3, 6)] 其他： N个iterable的则N元组， 惰性计算类似生成器、iter()，过一遍就没了 zip(*) 解压 1 2 3 4 5 6 7 8 9 10 11 12 13 14 a=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] b=[1,2,3,4] c=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;] # a,b,c -\u0026gt; 三元组 zip_abc=zip(a,b,c) print(list(zip_abc))\t# [(\u0026#39;a\u0026#39;, 1, \u0026#39;A\u0026#39;), (\u0026#39;b\u0026#39;, 2, \u0026#39;B\u0026#39;), (\u0026#39;c\u0026#39;, 3, \u0026#39;C\u0026#39;)] # 过一遍就没了，要重生成 print(list(zip_abc))\t# [] # 与 zip 相反，zip(*) 可理解为解压， aa, bb, cc = zip(*zip_abc) print(aa,bb,cc)\t# (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) (1, 2, 3) (\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) 把各个迭代对象压缩在一起，可以一起遍历，且惰性计算。（占空间小） map map(func, *iterables)\t创建一个迭代器(map)，存有各可迭代对象的参数依次执行函数计算的结果，当最短的可迭代对象耗尽时终止。 数据值处理 1 2 3 4 5 a=[1,2,3,4] b=[10,20,30,40] map_ab=map(lambda x,y:x+y,a,b) for i in map_ab: print(i,end=\u0026#39; \u0026#39;)\t# 11 22 33 44 数据类型处理，用上各种内置函数如int list str，但不括号 1 2 3 4 5 6 7 # 输入1 2，输出1 2，输入小数也会转为int类型 a,b = map(int, input().split()) print(a,b) # 字母大写 m = map(str.upper, [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;]) print(list(m)) # [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] reverse reversed(sequence, /) Return a reverse iterator over the values of the given sequence. 迭代器类型，占用空间没那么大，惰性计算，过一遍就没了\u0026hellip; 注意要加\u0026rsquo;d\u0026rsquo; reversed 1 2 3 a=[1,2,3] b=reversed(a) print([e for e in b])\t# [3,2,1] import_module 动态导入模块，尤其是在需要根据运行时条件（如配置文件、用户输入、插件系统等）决定加载哪些模块。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from importlib import import_module # 根据配置(字典)选择模块 config = {\u0026#34;DATABASE\u0026#34;: \u0026#34;mysql\u0026#34;} # 可能的值: \u0026#34;mysql\u0026#34;, \u0026#34;postgresql\u0026#34;, \u0026#34;sqlite\u0026#34; db_module = import_module(f\u0026#34;database.{config[\u0026#39;DATABASE\u0026#39;]}\u0026#34;) # main.py 中动态导入 utils # 目录结构 # mypackage / # |_ __init__.py # |_ utils.py # |_ main.py utils = import_module(\u0026#34;.utils\u0026#34;, package=\u0026#34;mypackage\u0026#34;) # package 参数指定了相对导入的基准包（即 . 的起点），package=\u0026#34;mypackage\u0026#34;， # 则 .utils 表示 mypackage.utils # 加载 plugins 目录下的所有插件 plugin_names = [\u0026#34;plugin1\u0026#34;, \u0026#34;plugin2\u0026#34;] # 可动态扫描目录获取 plugins = [] for name in plugin_names: plugin = import_module(f\u0026#34;plugins.{name}\u0026#34;) complex complex([real[, imag]])，返回复数 1 2 3 4 5 6 7 8 9 10 11 12 a=complex(1, 2)\tprint(a)\t# (1 + 2j) a=complex(1) print(a) # (1 + 0j) a=complex(\u0026#34;1\u0026#34;) print(a)\t# (1 + 0j) # 注意：这个地方在\u0026#34;+\u0026#34;号两边不能有空格，也就是不能写成\u0026#34;1 + 2j\u0026#34;，应该是\u0026#34;1+2j\u0026#34;，否则会报错 a=complex(\u0026#34;1+2j\u0026#34;) print(a)\t# (1 + 2j) hasattr hasattr(obj, name, /) Return whether the object has an attribute with the given name.\nhasattr(检查对象, 名字)\n检查对象（类实例、类、模块等）是否有 指定的 属性/方法，返回True/False\n属性/方法：字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 检查属性是否存在 class A: def __init__(self, name): self.name = name a = A(\u0026#34;Alice\u0026#34;) print(hasattr(a, \u0026#34;name\u0026#34;)) # 输出: True print(hasattr(a, \u0026#34;age\u0026#34;)) # 输出: False # 检查方法是否存在 class B: def add(self, a, b): return a + b print(hasattr(B, \u0026#34;add\u0026#34;)) # 输出: True print(hasattr(B, \u0026#34;multiply\u0026#34;)) # 输出: False 复习getattr、setattr rooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\nrooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\nrooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\trooobeam • 著\n10000词！\n","date":"2025-02-21T00:00:00Z","image":"https://rooobeam.github.io/p/python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/rz0sefu53fe_hu_359b55b65c1f5167.webp","permalink":"https://rooobeam.github.io/p/python3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","title":"Python3内置函数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # deepseek-r1生成后删减得来 import sys import platform import subprocess from importlib.metadata import distributions def get_environment_info(): env_info = { # 系统信息 \u0026#34;操作系统\u0026#34;: f\u0026#34;{platform.system()} {platform.release()} {platform.version()}\u0026#34;, \u0026#34;系统架构\u0026#34;: platform.architecture()[0], \u0026#34;主机名\u0026#34;: platform.node(), # Python环境 \u0026#34;Python版本\u0026#34;: sys.version.replace(\u0026#39;\\n\u0026#39;, \u0026#39; \u0026#39;), \u0026#34;虚拟环境\u0026#34;: \u0026#34;是\u0026#34; if hasattr(sys, \u0026#39;real_prefix\u0026#39;) or sys.prefix != sys.base_prefix else \u0026#34;否\u0026#34;, # 包管理信息 \u0026#34;已安装包\u0026#34;: [f\u0026#34;{dist.metadata[\u0026#39;Name\u0026#39;]}=={dist.version}\u0026#34; for dist in distributions()], } # 获取conda信息（如果可用） try: result = subprocess.run([\u0026#39;conda\u0026#39;, \u0026#39;list\u0026#39;], capture_output=True, text=True, check=True) env_info[\u0026#34;Conda包列表\u0026#34;] = result.stdout.splitlines() except: env_info[\u0026#34;Conda包列表\u0026#34;] = \u0026#39;conda list fail\u0026#39; pass return env_info if __name__ == \u0026#34;__main__\u0026#34;: info = get_environment_info() # 打印摘要信息 print(\u0026#34;=\u0026#34; * 50 + \u0026#34;\\n环境配置摘要:\\n\u0026#34; + \u0026#34;=\u0026#34; * 50) print(f\u0026#34;操作系统: {info[\u0026#39;操作系统\u0026#39;]}\u0026#34;) print(f\u0026#34;Python版本: {info[\u0026#39;Python版本\u0026#39;].split(\u0026#39; [\u0026#39;)[0]}\u0026#34;) print(f\u0026#34;虚拟环境: {info[\u0026#39;虚拟环境\u0026#39;]}\u0026#34;) print(f\u0026#34;已安装包数量: {len(info[\u0026#39;已安装包\u0026#39;])}\u0026#34;) # 保存完整信息到文件 with open(\u0026#34;environment_report.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: for key, value in info.items(): f.write(f\u0026#34;\\n=== {key} ===\\n\u0026#34;) if isinstance(value, list): f.write(\u0026#39;\\n\u0026#39;.join(value)) elif isinstance(value, dict): for k, v in value.items(): f.write(f\u0026#34;{k}: {v}\\n\u0026#34;) else: f.write(str(value)) print(\u0026#34;\\n完整环境报告已保存到 environment_report.txt\u0026#34;) ","date":"2025-02-21T00:00:00Z","image":"https://rooobeam.github.io/p/%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84txt/preview%281%29_hu_f70373dca115e4ca.jpg","permalink":"https://rooobeam.github.io/p/%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84txt/","title":"生成当前环境配置的txt"},{"content":"寄存器（内存访问） ✅\n(⊙﹏⊙) ","date":"2025-02-19T21:22:11+08:00","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%95%96%E5%85%89_hu_ca55c6edaf6ec37c.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/","title":"汇编语言第三章"},{"content":"第一个程序 ✅\n源程序写出到执行简要过程，后文有实例： 编写源程序 —— 写一个文本文件 —— 使用edit、笔记本等。 编译连接 —— 用汇编语言编译程序对文本文件编译产生目标文件；再用连接程序对目标文件进行连接，生成可执行文件。 在操作系统中执行文件。 ✅\n源程序简单结构 1 2 3 4 5 6 7 8 9 10 11 12 13 assume 寄存器:某segment段, 寄存器:某segment段, 寄存器:某segment段 XXX segment : : : XXX ends YYY segment : mov ax,4c00H int 21H YYY ends end 伪指令：提供给编译器的，编译器根据伪指令进行编译工作。上面代码中assume，XXX segment……XXX ends 和 end。 标号，如segment段的名称 上面代码中的XXX、YYY，一个标号指代一个地址。 程序返回：将CPU的控制权还给 使他得以运行的程序（shell)。代码中的 mov ax,4C00H \\n int 21H 。 ✅\n实例\n编写源程序 svg\n​\t桌面右键新建txt命名123，记事本里写好源程序。\n编译 svg\nwin+R 输入command打开命令提示符，输入“cd masm”（masm.exe所在目录），输入“masm”启动masm.exe。 提示我们输入源文件名，txt文件放在了c:\\asm，且不是asm文件，输入c:\\asm\\123.txt。 询问生成obj文件名，我们选择默认，回车即可。 提示输入列表文件名，该文件为编译为目标文件的中间结果，我们不生成，回车即可。 提示输入交叉引用文件名，也是中间结果，不生成，回车即可。 无错误则masm.exe所在目录下生成123.obj 连接 svg\n进入DOS方式(win+R 输command)，进入c:/masm (Overlay Linker3.60，link.exe所在目录),输入link启动link.exe。 提示输入目标文件名，[.OBJ]提示默认扩展名为obj，正合我意，输入123即可。 提示生成的exe文件名，默认名就行，回车即可。 提示输入映像文件名，提示输入库文件名，我们都回车即可。 无error则当前目录下生成123.exe。 执行，命令行输入文件名就行了，masm.exe 或 masm 123.exe 或 123 。\ndebug跟踪程序的运行过程：debug 可以将程序载入内存，设置CS:IP指向程序的入口，但debug不放弃cpu的控制权\n具体方法：debug 123.exe svg 运用第二章的debug的使用方法 R命令查看、改变寄存器内容 D查看内存中内容 E改写内存内容 U将内存中机器指令(01\u0026hellip;)翻译以为汇编命令(mov\u0026hellip;) T执行一条机器指令 A以汇编指令格式往内存写入机器指令 P正常结束程序。 实操如下图： svg ✅\nexe执行过程与shell DOS中，123.exe若要运行，要有一个正在运行的程序p2将其载入内存，123.exe运行完后即将cpu控制权交还程序p2。 p2即command.com，被成为命令解释器，即DOS系统的shell。输入cd、dir、type等都由command执行。 提示符\u0026quot;c:\\masm“后输入123.exe，此时command.com运行。 输入123.3exe后，command根据文件名找到该可执行文件，将程序载入内存，设置CS:IP指向程序入口，随后执行程序。 执行完回到command。 dos中.exe的加载过程（上面第二步——载入内存） 找到SA:0000空闲内存区——\u0026gt;前256即偏移地址0-255创程序段前缀(PSP)，DOS要用它和.exe通信——\u0026gt;后面装入程序，即从SA+10H:0000——\u0026gt;CS:IP=SA+10H:0000 加载.svg ✅\n习题 习题.svg ","date":"2025-02-19T00:00:00Z","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%B8%89%E9%BE%99_hu_87bde1cf9b7bc30f.jpg","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/","title":"汇编语言第四章"},{"content":"寄存器 ✅\n8086cpu有14个寄存器：AX BX CX DS SI DI SP BP IP CS SS DS ES PSW。\n8086cpu寄存器都是16位的。\nABCD-X通常用来存放一般性数据，被成为通用寄存器。\n寄存器?X可被分为?H和?L，如AX分为AH AL，即分为AHigh ALow，前者是高八位，后者是第八位。\n所谓高位和数字的高位联想，都是左边是高位。\n✅\n几条汇编指令：mov add，用法一样。add ax,18H; add ax,8H。\n数字默认16进制。\nmov ax,bx; mov ax,7。\n两个操作对象位数一致，第一个位置要是变量，如mov ah,bl; mov bh, AA。\n✅\n物理地址即内存在统一的逻辑存储器中的地址。\n内存地址空间:cpu将系统中各类存储器看作一个逻辑存储器。\n物理地址=段地址*16+偏移地址，通常写作 段地址:偏移地址，如cpu指令读取开始地址CS:IP。\n由于十六进制，故其实即 “段地址0+偏移地址”，由一个地址加法器合成。\n段的概念：段地址固定，偏移地址连续的内存空间。故其最大范围0000~FFFF。实践发现，0-1会自动变成FFFF，FFFF+1变成0000。\n✅\n8086有四个段寄存器：CS DS SS ES。\nCS和IP：CS叫代码 段寄存器，IP 叫指令指针寄存器，CS存段地址IP存偏移量。\ncpu将从CS:IP单元开始读取一条指令并执行。\n取指执行过程：从CS:IP读取指令，该指令进入指令缓冲器；IP=IP+该指令长度，从而指向下一指令首单元；执行指令；从CS:IP读取指令\u0026hellip;\u0026hellip;.\n修改CS IP命令——jmp jmp 段地址:偏移地址\t段地址修改CS 偏移地址修改IP jmp “四位数” 仅修改IP jmp 某合法寄存器\t仅修改IP，IP=某合法寄存器的值\n","date":"2025-02-12T22:10:35+08:00","image":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/vglcjtiwyh9bnm0o_hu_b0d85bfc829806f3.webp","permalink":"https://rooobeam.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"汇编语言第二章"},{"content":"正文 设备：win2000VM虚拟机，win11宿主机\nwin11上：如何搭建FTP：https://zhuanlan.zhihu.com/p/36070173\nwin2000上：\n调为NAT模式； 我的电脑-\u0026gt;网上邻居-\u0026gt;地址栏输入ftp://宿主机wlan地址 搞定。\n？？？\n","date":"2025-02-05T13:08:00+08:00","permalink":"https://rooobeam.github.io/p/ftp%E5%AE%9E%E8%B7%B5/","title":"Ftp实践"},{"content":"","date":"2025-01-18T10:28:00+08:00","permalink":"https://rooobeam.github.io/p/newblog/","title":"Newblog"},{"content":"","date":"2025-01-18T09:50:26+08:00","permalink":"https://rooobeam.github.io/p/newtest/","title":"Newtest"},{"content":"hello hi fine 测试简体中文能否显示\n","date":"2025-01-17T19:46:01+08:00","permalink":"https://rooobeam.github.io/p/firstblog/","title":"FirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://rooobeam.github.io/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"https://rooobeam.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://rooobeam.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://rooobeam.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://rooobeam.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://rooobeam.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://rooobeam.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://rooobeam.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://rooobeam.github.io/p/emoji-support/","title":"Emoji Support"}]